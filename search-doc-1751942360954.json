{"searchDocs":[{"title":"hashMapRetry","type":0,"sectionRef":"#","url":"/lyra/api/hashMapRetry","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"hashMapRetry","url":"/lyra/api/hashMapRetry#functions","content":" ","version":null,"tagName":"h2"},{"title":"hashMapRetry​","type":1,"pageTitle":"hashMapRetry","url":"/lyra/api/hashMapRetry#hashMapRetry","content":"&lt;/&gt; hashMapRetry.hashMapRetry( func: () → any-- The function to execute and potentially retry. This function should perform the desired MemoryStore HashMap operation (e.g., GetAsync, SetAsync, UpdateAsync). It should return the result on success or throw an error on failure. ) → RetryHandle&lt;Promise&lt;any&gt;&gt;-- A handle containing: promise (A Promise that resolves with the return value of func if it succeeds within MAX_RETRIES attempts) and cancel (A function that, when called, attempts to stop further retries and rejects the promise). Wraps a function that performs a MemoryStore HashMap operation, automatically retrying it if it fails with specific transient error message substrings. Implements an exponential backoff strategy: waits 1s, 2s, 4s, 8s between retries. Includes a cancellation mechanism via the returned [RetryHandle]. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"hashMapRetry","url":"/lyra/api/hashMapRetry##","content":"Type\tDescriptionstring\tRejects if `func` fails with a non-retriable error, if it fails with a retriable error `MAX_RETRIES` times, or if `cancel()` is called. ","version":null,"tagName":"h3"},{"title":"Constants","type":0,"sectionRef":"#","url":"/lyra/api/Constants","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Constants","url":"/lyra/api/Constants#types","content":" ","version":null,"tagName":"h2"},{"title":"Constants​","type":1,"pageTitle":"Constants","url":"/lyra/api/Constants#Constants","content":"&lt;/&gt; interface Constants { RECORD_SCOPE: &quot;lyra/records&quot;-- Scope prefix used for keys storing the main DataStoreRecord objects. TX_SCOPE: &quot;lyra/tx&quot;-- Scope prefix used for keys storing transaction status markers in a DataStore. SHARD_SCOPE: &quot;lyra/shards&quot;-- Scope prefix used for keys storing data shards in a DataStore. LOCK_SCOPE: &quot;lyra/locks&quot;-- Scope prefix used for keys storing lock information in a MemoryStore HashMap. MAX_CHUNK_SIZE: number-- Maximum size (in bytes) for a single data shard stored in DataStore. Derived from the Roblox DataStore value limit (4MB) minus a reserved amount (INTERNAL_SPACE_RESERVE_BYTES) for Lyra's internal metadata within the main record. LOCK_REFRESH_INTERVAL_SECONDS: number-- How often (in seconds) a held lock should be refreshed in MemoryStore to prevent it from expiring while still actively being used. Should be significantly shorter than LOCK_DURATION_SECONDS. LOCK_DURATION_SECONDS: number-- The initial time-to-live (TTL) duration (in seconds) for a lock acquired in MemoryStore. If the lock isn't refreshed within this time, it will automatically expire. Must be longer than LOCK_REFRESH_INTERVAL_SECONDS to allow time for refreshes. AUTOSAVE_INTERVAL_SECONDS: number-- How often (in seconds) the automatic saving mechanism should attempt to save dirty session data. }  ","version":null,"tagName":"h3"},{"title":"dataStoreRetry","type":0,"sectionRef":"#","url":"/lyra/api/dataStoreRetry","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"dataStoreRetry","url":"/lyra/api/dataStoreRetry#functions","content":" ","version":null,"tagName":"h2"},{"title":"dataStoreRetry​","type":1,"pageTitle":"dataStoreRetry","url":"/lyra/api/dataStoreRetry#dataStoreRetry","content":"&lt;/&gt; dataStoreRetry.dataStoreRetry( func: () → T-- The function to execute and potentially retry. This function should perform the desired DataStore operation (e.g., GetAsync, SetAsync, UpdateAsync). It should return the result of the operation on success or throw an error on failure. ) → Promise&lt;T&gt;-- A Promise that resolves with the return value of func if it succeeds within MAX_RETRIES attempts. Wraps a function that performs a DataStore operation, automatically retrying it if it fails with specific transient error codes. Implements an exponential backoff strategy: waits 1s, 2s, 4s, 8s between retries. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"dataStoreRetry","url":"/lyra/api/dataStoreRetry##","content":"Type\tDescriptionstring\tRejects with the error message if `func` fails with a non-retriable error code, or if it fails with a retriable error code `MAX_RETRIES` times. ","version":null,"tagName":"h3"},{"title":"Locks","type":0,"sectionRef":"#","url":"/lyra/api/Locks","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#types","content":" ","version":null,"tagName":"h2"},{"title":"LockHandle​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#LockHandle","content":"&lt;/&gt; interface LockHandle { release: () → Promise-- Releases the lock immediately. Stops the refresh loop and attempts to clear the lock key in MemoryStore (by setting TTL to 0). Resolves when the release attempt is complete. isLocked: () → boolean-- Checks if the lock is currently considered held locally. This checks both the internal status and compares the last confirmed expiry time (from MemoryStore) against the current local time. True if the lock is believed to be held. onLockLost: (() → ()) → (() → ())-- Registers a callback function to be invoked if the lock is lost unexpectedly (e.g., refresh fails, TTL expires). Returns a function to disconnect/unregister the callback. } Represents an acquired lock handle, providing methods to interact with the lock.  ","version":null,"tagName":"h3"},{"title":"AcquireLockParams​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#AcquireLockParams","content":"&lt;/&gt; interface AcquireLockParams { storeContext: Types.StoreContext&lt;any&gt;-- Shared store context containing logger and MemoryStoreHashMap instance. key: string-- The unique key identifying the resource to be locked. duration: number-- The duration (TTL) in seconds for which the lock should be held/refreshed. refreshInterval: number-- The interval in seconds at which the lock refresh should be attempted. } Parameters for acquiring a lock.  ","version":null,"tagName":"h3"},{"title":"ProbeLockActiveParams​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#ProbeLockActiveParams","content":"&lt;/&gt; interface ProbeLockActiveParams { storeContext: Types.StoreContext&lt;any&gt;-- Shared store context containing logger and MemoryStoreHashMap instance. key: string-- The unique key identifying the resource to be locked. } Parameters for probing if a lock is active. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#functions","content":" ","version":null,"tagName":"h2"},{"title":"acquireLock​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#acquireLock","content":"&lt;/&gt; Locks.acquireLock( params: AcquireLockParams-- Configuration for the lock acquisition. ) → Promise&lt;LockHandle&gt;-- Resolves with a LockHandle if the lock is acquired successfully. Attempts to acquire a distributed lock for the specified key. Manages the lock acquisition process, including retries with exponential backoff, setting up the background refresh loop, and providing a LockHandle on success. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks##","content":"Type\tDescriptionRejects if the lock cannot be acquired within the specified duration/attempts, or if other MemoryStore errors occur.\t  ","version":null,"tagName":"h3"},{"title":"probeLockActive​","type":1,"pageTitle":"Locks","url":"/lyra/api/Locks#probeLockActive","content":"&lt;/&gt; Locks.probeLockActive( params: ProbeLockActiveParams-- Parameters for probing the lock. ) → Promise&lt;boolean&gt;-- Resolves with true if the lock key exists, false otherwise. Checks if a lock key currently exists in MemoryStore without attempting to acquire it. Useful for determining if another process likely holds the lock. Note: This is a point-in-time check and doesn't guarantee the lock state won't change immediately after the check completes. ","version":null,"tagName":"h3"},{"title":"Lyra","type":0,"sectionRef":"#","url":"/lyra/api/Lyra","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Lyra","url":"/lyra/api/Lyra#types","content":" ","version":null,"tagName":"h2"},{"title":"MigrationStep​","type":1,"pageTitle":"Lyra","url":"/lyra/api/Lyra#MigrationStep","content":"&lt;/&gt; interface MigrationStep { field: addFields( name: string, fields: {[string]: any} ) → MigrationStep-- Creates a step to add new fields with default values. field: transform( name: string, transformFunc: (currentValue: {[string]: any}) → {[string]: any} ) → MigrationStep-- Creates a step with a custom data transformation function. } Provides helper functions for creating common migration steps. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Lyra","url":"/lyra/api/Lyra#functions","content":" ","version":null,"tagName":"h2"},{"title":"createPlayerStore<T>​","type":1,"pageTitle":"Lyra","url":"/lyra/api/Lyra#createPlayerStore<T>","content":"&lt;/&gt; Lyra.createPlayerStore&lt;T&gt;( context: PlayerStoreConfig&lt;T&gt;-- The configuration for the PlayerStore. ) → PlayerStore&lt;T&gt;-- A new PlayerStore instance. Factory function to create a new PlayerStore instance.  ","version":null,"tagName":"h3"},{"title":"setLogLevel​","type":1,"pageTitle":"Lyra","url":"/lyra/api/Lyra#setLogLevel","content":"&lt;/&gt; Lyra.setLogLevel( level: LogLevel-- The minimum log level (&quot;fatal&quot;, &quot;error&quot;, &quot;warn&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;trace&quot;). ) → () Sets the global minimum log level for all Lyra loggers. ","version":null,"tagName":"h3"},{"title":"Files","type":0,"sectionRef":"#","url":"/lyra/api/Files","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#types","content":" ","version":null,"tagName":"h2"},{"title":"WriteParams​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#WriteParams","content":"&lt;/&gt; interface WriteParams { store: DataStore -- The DataStore instance to write to. data: any-- The Luau data to be stored. Must be JSON-encodable. maxShardSize: number-- The maximum size (in bytes) allowed for a single shard. Data exceeding this size after initial JSON encoding will trigger the sharding process. key: string-- The primary key under which the file metadata (or the full data if not sharded) will be conceptually associated. This key is not directly used for storing shards. userIds: {number}?-- An optional array of UserIDs for DataStore tagging. } Parameters required for the write function.  ","version":null,"tagName":"h3"},{"title":"WriteError​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#WriteError","content":"&lt;/&gt; interface WriteError { error: string-- A string describing the error. file: File-- The file metadata that was being processed when the error occurred. This is used for cleanup operations if shards were partially written. } Structure representing an error encountered during the write operation.  ","version":null,"tagName":"h3"},{"title":"ReadParams​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#ReadParams","content":"&lt;/&gt; interface ReadParams { store: DataStore -- The DataStore instance to read from. file: File-- The File object obtained from a previous write operation or retrieved from the primary DataStore key. This object determines whether to read directly or reconstruct from shards. } Parameters required for the read function. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#functions","content":" ","version":null,"tagName":"h2"},{"title":"splitString​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#splitString","content":"&lt;/&gt; Files.splitString( str: string,-- The string to be split. chunkSize: number-- The size of each chunk. ) → {string}-- A table containing the split chunks. Splits a string into chunks of a specified size. Used for sharding large data blobs into smaller pieces.  ","version":null,"tagName":"h3"},{"title":"isLargeFile​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#isLargeFile","content":"&lt;/&gt; Files.isLargeFile( file: File-- The file object to check. ) → boolean-- True if the file is sharded, false otherwise. Checks if a file object represents a sharded file (i.e., data stored across multiple keys).  ","version":null,"tagName":"h3"},{"title":"write​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#write","content":"&lt;/&gt; Files.write( params: WriteParams-- The parameters for the write operation. ) → Promise&lt;File&gt;-- A Promise that resolves with a File object representing the stored data (either directly containing the data or shard metadata). Writes data to the DataStore, automatically handling sharding and compression if necessary. If the JSON-encoded data is smaller than maxShardSize, it's stored directly within the returned File object (in the data field). If the data is larger, it's compressed, sharded, and stored across multiple DataStore keys. The returned File object will contain shard (the unique ID for the shards) and count (the number of shards) instead of the data field. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Files","url":"/lyra/api/Files##","content":"Type\tDescriptionWriteError\tRejects with a `WriteError` if any shard fails to write. string\tPropagates errors from `DataStore:SetAsync` via `dataStoreRetry`.  ","version":null,"tagName":"h3"},{"title":"read​","type":1,"pageTitle":"Files","url":"/lyra/api/Files#read","content":"&lt;/&gt; Files.read( params: ReadParams-- The parameters for the read operation. ) → Promise&lt;any&gt;-- A Promise that resolves with the original data. Reads data from the DataStore, automatically handling reconstruction from shards if necessary. If the provided file object contains the data field directly, it returns that data. If the file object contains shard and count fields, it reads all corresponding shards from the DataStore, concatenates them, decompresses the result, and returns the original data. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Files","url":"/lyra/api/Files##","content":"Type\tDescriptionstring\tRejects with an error message string if any shard is missing or if decoding/decompression fails. Propagates errors from `DataStore:GetAsync` via `dataStoreRetry`. ","version":null,"tagName":"h3"},{"title":"Migrations","type":0,"sectionRef":"#","url":"/lyra/api/Migrations","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#types","content":" ","version":null,"tagName":"h2"},{"title":"ApplyParams​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#ApplyParams","content":"&lt;/&gt; interface ApplyParams { logger: Log.Logger-- Logger instance for logging migration progress and errors. data: Data-- The current data loaded from the DataStore record's File. steps: {Types.MigrationStep}-- The list of all defined migration steps for the store. appliedMigrations: {string}-- The list of names of migration steps already applied to this specific data record, loaded from the DataStoreRecord. } Parameters for the apply function.  ","version":null,"tagName":"h3"},{"title":"ApplyResult​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#ApplyResult","content":"&lt;/&gt; interface ApplyResult { data: Data-- The potentially modified data after applying necessary migration steps. appliedMigrations: {string}-- The updated list of applied migration names, including any newly applied steps. This should be saved back to the DataStoreRecord. } Result returned by the apply function upon successful completion. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#functions","content":" ","version":null,"tagName":"h2"},{"title":"validate​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#validate","content":"&lt;/&gt; Migrations.validate( steps: {Types.MigrationStep}-- The list of migration steps to validate. ) → () Validates that the provided migration steps adhere to the expected structure. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations##","content":"Type\tDescriptionstring\tThrows an error if any step is malformed.  ","version":null,"tagName":"h3"},{"title":"makeAddFieldsStep​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#makeAddFieldsStep","content":"&lt;/&gt; Migrations.makeAddFieldsStep( name: string,-- The unique name for this migration step. fields: Data-- A table containing the new fields and their default values. ) → Types.MigrationStep-- A migration step object. Helper function to create a common type of migration step: adding new fields with default values to existing data. Uses a deep merge strategy.  ","version":null,"tagName":"h3"},{"title":"makeTransformStep​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#makeTransformStep","content":"&lt;/&gt; Migrations.makeTransformStep( name: string,-- The unique name for this migration step. transformFunc: (currentValue: Data) → Data-- The function that takes the current data and returns the transformed data. ) → Types.MigrationStep-- A migration step object. Helper function to create a migration step that applies a custom transformation function to the data.  ","version":null,"tagName":"h3"},{"title":"apply​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#apply","content":"&lt;/&gt; Migrations.apply( params: ApplyParams-- The parameters for applying migrations. ) → Promise&lt;ApplyResult&gt;-- A Promise that resolves with the updated data and the new list of applied migration names. Applies pending migration steps to the data. Iterates through the defined steps and applies any step whose name is not present in the appliedMigrations list. Ensures idempotency and uses pcall for safe execution of each step's apply function. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations##","content":"Type\tDescriptionstring\tRejects if any migration step fails during `pcall`.  ","version":null,"tagName":"h3"},{"title":"getStepNames​","type":1,"pageTitle":"Migrations","url":"/lyra/api/Migrations#getStepNames","content":"&lt;/&gt; Migrations.getStepNames( migrations: {Types.MigrationStep}-- The list of migration steps. ) → {string}-- A list containing only the names of the migration steps. Utility function to extract just the names from a list of migration steps. ","version":null,"tagName":"h3"},{"title":"Log","type":0,"sectionRef":"#","url":"/lyra/api/Log","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#types","content":" ","version":null,"tagName":"h2"},{"title":"LogLevel​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#LogLevel","content":"enum &lt;/&gt; type LogLevel = &quot;fatal&quot; | &quot;error&quot; | &quot;warn&quot; | &quot;info&quot; | &quot;debug&quot; | &quot;trace&quot; Represents the different log levels available for logging messages.  ","version":null,"tagName":"h3"},{"title":"LogMessage​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#LogMessage","content":"&lt;/&gt; interface LogMessage { message: string-- The main content of the log message. level: LogLevel-- The severity level of the message. context: {[string]: any}?-- Optional table containing additional structured context. } Represents a log message sent to the logger's callback function. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#functions","content":" ","version":null,"tagName":"h2"},{"title":"setLevel​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#setLevel","content":"&lt;/&gt; Log.setLevel( level: LogLevel-- The minimum log level to allow. ) → () Sets the global minimum log level. Messages with a severity lower than this level will be ignored by all loggers. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Log","url":"/lyra/api/Log##","content":"Type\tDescriptionstring\tThrows an error if the provided level is invalid.  ","version":null,"tagName":"h3"},{"title":"createLogger​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#createLogger","content":"&lt;/&gt; Log.createLogger( logCallback: (logMessage: LogMessage) → (),-- The function that will be called for each log message that passes the level filter. This function receives the complete LogMessage object including merged context. context: {[string]: any}?-- Optional initial context for this logger. ) → Logger-- A new Logger instance. Factory function to create a new root Logger instance.  ","version":null,"tagName":"h3"},{"title":"log​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#log","content":"&lt;/&gt; Log:log( level: LogLevel,-- The severity level of the message. message: string,-- The log message content. context: {[string]: any}?-- Optional additional context specific to this log call. ) → () Logs a message if its level is at or above the globally set log level. Merges the provided context table with the logger's persistent context before calling the configured _logCallback.  ","version":null,"tagName":"h3"},{"title":"extend​","type":1,"pageTitle":"Log","url":"/lyra/api/Log#extend","content":"&lt;/&gt; Log:extend( context: {[string]: any}-- The additional context fields to add. ) → Logger-- A new Logger instance with the extended context. Creates a new Logger instance that inherits the parent's callback but has an extended context. The new logger's context is a merged table containing the parent's context and the additional context provided here. ","version":null,"tagName":"h3"},{"title":"PromiseQueue","type":0,"sectionRef":"#","url":"/lyra/api/PromiseQueue","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"PromiseQueue","url":"/lyra/api/PromiseQueue#types","content":" ","version":null,"tagName":"h2"},{"title":"CreatePromiseQueueParams​","type":1,"pageTitle":"PromiseQueue","url":"/lyra/api/PromiseQueue#CreatePromiseQueueParams","content":"&lt;/&gt; interface CreatePromiseQueueParams { logger: Log.Logger } Parameters for creating a new PromiseQueue instance. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"PromiseQueue","url":"/lyra/api/PromiseQueue#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"PromiseQueue","url":"/lyra/api/PromiseQueue#new","content":"&lt;/&gt; PromiseQueue.new( params: CreatePromiseQueueParams-- Configuration parameters. ) → PromiseQueue-- A new PromiseQueue object. Creates a new PromiseQueue instance.  ","version":null,"tagName":"h3"},{"title":"multiQueueAdd​","type":1,"pageTitle":"PromiseQueue","url":"/lyra/api/PromiseQueue#multiQueueAdd","content":"&lt;/&gt; PromiseQueue.multiQueueAdd( queues: {PromiseQueue},-- A table array of PromiseQueue instances to coordinate. callback: () → ()-- The function to execute once all queues are ready. ) → Promise-- A Promise that resolves/rejects with the result/error of the callback. Atomically adds a callback function to be executed across multiple queues. Ensures that the callback only runs when it has effectively acquired the &quot;lock&quot; (become the currently processing item) on all specified queues simultaneously. This is useful for operations that need to coordinate across multiple resources managed by separate queues. Mechanism: Uses _addResumableBlock to add a blocking item to each queue. Waits for all these blocking items to become active (i.e., all _addResumableBlock promises resolve, returning their resume functions). Once all queues are blocked, executes the provided callback. After the callback finishes (successfully or with an error), calls all the resume functions to unblock all the queues.   ","version":null,"tagName":"h3"},{"title":"add​","type":1,"pageTitle":"PromiseQueue","url":"/lyra/api/PromiseQueue#add","content":"&lt;/&gt; PromiseQueue:add( callback: () → T-- The function to execute. This function can be synchronous or return a Promise. Its result or error will resolve/reject the Promise returned by this add call. ) → Promise&lt;T&gt;-- A Promise that resolves or rejects with the result or error of the provided callback function once it's processed by the queue. Adds a new operation (callback function) to the end of the queue. The callback will be executed only after all preceding items in the queue have completed. ","version":null,"tagName":"h3"},{"title":"Session","type":0,"sectionRef":"#","url":"/lyra/api/Session","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#types","content":" ","version":null,"tagName":"h2"},{"title":"Session<T>​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#Session<T>","content":"&lt;/&gt; type Session&lt;T&gt; = typeof(setmetatable({}:: SessionProps&lt;T&gt;,{}:: SessionImpl&lt;T&gt;)) Represents an active, locked session for a specific data key. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#functions","content":" ","version":null,"tagName":"h2"},{"title":"load​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#load","content":"&lt;/&gt; Session.load( params: LoadSessionParams&lt;T&gt;-- Parameters for loading the session. ) → Promise&lt;Session&lt;T&gt;&gt;-- Resolves with the new Session instance. Static method to load data and create a Session. This is the main entry point called by Store:load. Steps: Acquire the distributed lock for the key using Locks.acquireLock. If lock acquired, call the internal load helper function. If load successful and lock still held, create the Session instance using createSession. Set up lock loss handling (lockHandle.onLockLost) to close the session. Initiate background cleanup for any orphaned files found during load. Set the initial data in the session using mutateKey. Return the created Session. Ensure the lock is released if loading fails at any stage. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Session","url":"/lyra/api/Session##","content":"Type\tDescription&quot;Lock was lost while loading key&quot; string\tPropagates errors from `Locks.acquireLock` or internal `load`.  ","version":null,"tagName":"h3"},{"title":"isSaved​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#isSaved","content":"&lt;/&gt; Session:isSaved() → boolean-- True if there are no unsaved changes, false otherwise. Checks if the session has any unsaved changes.  ","version":null,"tagName":"h3"},{"title":"startAutosaving​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#startAutosaving","content":"&lt;/&gt; Session:startAutosaving() → () Starts the background autosave loop for this session. Does nothing if already started or if the session is closed.  ","version":null,"tagName":"h3"},{"title":"stopAutosaving​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#stopAutosaving","content":"&lt;/&gt; Session:stopAutosaving() → () Stops the background autosave loop if it's running.  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#unload","content":"&lt;/&gt; Session:unload() → Promise-- Resolves when the unload process is complete. Initiates the graceful shutdown process for the session. Stops autosaving, queues a final save operation, and releases the lock.  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#get","content":"&lt;/&gt; Session:get() → Promise&lt;T&gt;-- Resolves immediately with the data. Gets the current data for the session. Value returned is deep frozen to prevent modification.  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#update","content":"&lt;/&gt; Session:update( transformFunction: (data: T) → boolean-- Function to modify data. Must return true to commit, false to abort. ) → Promise&lt;boolean&gt;-- Resolves with true if changes were committed, false if aborted by the transform. Applies updates to the session's data via a transform function. Ensures the transform runs without yielding and validates the result against the schema. Allows you to directly mutate the data in-place. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Session","url":"/lyra/api/Session##","content":"Type\tDescription&quot;Session is closed&quot; &quot;transformFunction failed: ...&quot;\tIf the transform function errors. &quot;transformFunction must return a boolean&quot; &quot;Store:update schema validation failed: ...&quot;\tIf the modified data fails schema validation.  ","version":null,"tagName":"h3"},{"title":"updateImmutable​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#updateImmutable","content":"&lt;/&gt; Session:updateImmutable( transformFunction: (data: T) → T | false-- Function to modify data. Must return a new copy of the data with changes to commit changes, or false to abort. ) → Promise&lt;boolean&gt;-- Resolves with true if changes were committed, false if aborted by the transform. Applies updates to the session's data via a transform function. Ensures the transform runs without yielding and validates the result against the schema. Requires the use of copy-on-write semantics in transformFunction, where the data is not directly mutated but instead a new copy is returned. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Session","url":"/lyra/api/Session##","content":"Type\tDescription&quot;Session is closed&quot; &quot;transformFunction failed: ...&quot;\tIf the transform function errors. &quot;transformFunction must return a boolean&quot; &quot;Store:update schema validation failed: ...&quot;\tIf the modified data fails schema validation.  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"Session","url":"/lyra/api/Session#save","content":"&lt;/&gt; Session:save() → Promise-- Resolves when the save operation completes (or immediately if no changes). Queues a save operation for the current session state if changes are pending. Uses the session's PromiseQueue to serialize saves. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Session","url":"/lyra/api/Session##","content":"Type\tDescription&quot;Session is closed&quot;\t ","version":null,"tagName":"h3"},{"title":"Transactions","type":0,"sectionRef":"#","url":"/lyra/api/Transactions","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Transactions","url":"/lyra/api/Transactions#types","content":" ","version":null,"tagName":"h2"},{"title":"ReadTxParams​","type":1,"pageTitle":"Transactions","url":"/lyra/api/Transactions#ReadTxParams","content":"&lt;/&gt; interface ReadTxParams { store: DataStore -- The DataStore instance where transaction status markers are stored. txInfo: Types.TxInfo-- The transaction information associated with the data being read. } Parameters required for the readTx function. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Transactions","url":"/lyra/api/Transactions#functions","content":" ","version":null,"tagName":"h2"},{"title":"readTx​","type":1,"pageTitle":"Transactions","url":"/lyra/api/Transactions#readTx","content":"&lt;/&gt; Transactions.readTx( params: ReadTxParams-- The parameters for the read operation. ) → Promise&lt;any&gt;-- A Promise that resolves with the appropriate data (either committed or patched). Reads data, considering the status of an associated transaction. Checks the status of the transaction ID (txInfo.txId) in the DataStore. If txId is nil (meaning no transaction was associated or it was cleaned up), returns the committedData directly. If txId exists: Fetches the status from the DataStore using the txId as the key. Status Convention: nil: The transaction successfully committed. The corresponding txPatch should be applied to committedData. false: The transaction is still in progress or failed/rolled back. The committedData (state before the transaction) should be returned. Applies the patch if the status is nil and a patch exists. Returns committedData if the status is false. Using nil to indicate a successful transaction allows for easier cleanup of transaction markers in the DataStore. Instead of setting the marker to true and only removing it after the txId is no longer needed, we can simply delete the marker immediately after a successful transaction. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Transactions","url":"/lyra/api/Transactions##","content":"Type\tDescriptionstring\tRejects if the transaction status indicates commitment (`nil`) but the `txPatch` is missing, or if DataStore operations fail (via `dataStoreRetry`). Propagates errors from `DataStore:GetAsync` via `dataStoreRetry`. ","version":null,"tagName":"h3"},{"title":"Debugging","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/debugging","content":"","keywords":"","version":"Next"},{"title":"Understanding Logs​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#understanding-logs","content":" Each log message contains:  A severity levelA descriptive messageOptional context with additional details  Here's a basic setup that prints all logs:  local function handleLogs(message) print(`[Lyra][{string.upper(message.level)}] {message.message}`) if message.context then -- Context contains relevant data like keys, session info, etc. print(&quot;Context:&quot;, message.context) end end local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, logCallback = handleLogs, })   ","version":"Next","tagName":"h2"},{"title":"Log Levels​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#log-levels","content":" Lyra uses different levels to categorize logs:  local function handleLogs(message) -- Handle based on severity if message.level == &quot;fatal&quot; then -- Unrecoverable errors (e.g., corrupted data) warn(&quot;FATAL:&quot;, message.message) elseif message.level == &quot;error&quot; then -- Operation failures (e.g., update failed) warn(&quot;Error:&quot;, message.message) elseif message.level == &quot;warn&quot; then -- Potential issues (e.g., slow operations) warn(&quot;Warning:&quot;, message.message) elseif message.level == &quot;info&quot; then -- Important operations (e.g., session started) print(&quot;Info:&quot;, message.message) elseif message.level == &quot;debug&quot; then -- Detailed operation info print(&quot;Debug:&quot;, message.message) elseif message.level == &quot;trace&quot; then -- Very detailed debugging info print(&quot;Trace:&quot;, message.message) end end   ","version":"Next","tagName":"h2"},{"title":"Development Mode​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#development-mode","content":" You often want more detailed logs in Studio:  local RunService = game:GetService(&quot;RunService&quot;) local function createLogger() if RunService:IsStudio() then -- Show all logs in Studio return function(message) print(`[Lyra][{message.level}] {message.message}`) if message.context then print(&quot;Context:&quot;, message.context) end end else -- Only show errors in production return function(message) if message.level == &quot;error&quot; or message.level == &quot;fatal&quot; then warn(`[Lyra] {message.message}`) end end end end local store = Lyra.createPlayerStore({ logCallback = createLogger(), })   tip The context object often contains useful debugging information like session IDs, keys being operated on, and timing data.  ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#see-also","content":" Core Concepts for understanding operationsGetting Started for basic setup ","version":"Next","tagName":"h2"},{"title":"Types","type":0,"sectionRef":"#","url":"/lyra/api/Types","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#types","content":" ","version":null,"tagName":"h2"},{"title":"PatchOperation​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#PatchOperation","content":"&lt;/&gt; interface PatchOperation { op: &quot;add&quot; | &quot;replace&quot; | &quot;remove&quot;-- The operation type. path: string-- A JSON Pointer string indicating the target location. value: any?-- The value to add or replace (used for &quot;add&quot; and &quot;replace&quot;). Optional for &quot;remove&quot;. } Represents a single operation within a JSON Patch array. Used for describing changes between data states.  ","version":null,"tagName":"h3"},{"title":"TxPatch​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#TxPatch","content":"&lt;/&gt; type TxPatch = {PatchOperation} An array of PatchOperation objects representing the changes made during a transaction.  ","version":null,"tagName":"h3"},{"title":"TxInfo​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#TxInfo","content":"&lt;/&gt; interface TxInfo { committedData: any-- The last known data state that was successfully saved to the primary DataStore record before the transaction identified by txId began. txId: string?-- The unique identifier of the transaction currently attempting to modify this data. If nil, no transaction is active or the last one completed and was cleaned up. txPatch: TxPatch?-- The set of changes (JSON Patch) applied by the transaction identified by txId. This is used to reconstruct the final state if the transaction is confirmed as committed. } Holds information about the state of data potentially involved in a transaction. Used by the Transactions module to determine the correct data to return during reads.  ","version":null,"tagName":"h3"},{"title":"File​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#File","content":"&lt;/&gt; interface File { data: any?-- The actual data, if it was stored directly (not sharded). Mutually exclusive with shard and count. shard: string?-- The unique identifier for the set of shards, if the data was sharded. Mutually exclusive with data. count: number?-- The total number of shards, if the data was sharded. Mutually exclusive with data. } Represents the stored data, abstracting away the sharding mechanism. If the data was small enough, it's stored directly in the data field. If the data was large and sharded, shard and count are present instead, pointing to the location and number of data shards stored separately.  ","version":null,"tagName":"h3"},{"title":"DataStoreRecord​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#DataStoreRecord","content":"&lt;/&gt; interface DataStoreRecord { appliedMigrations: {string}-- A list of names of migration steps that have already been successfully applied to the data associated with this record. Initialized as empty. file: File-- A File object representing the actual user data. This might contain the data directly or point to shards. orphanedFiles: {File}-- A list of sharded File objects that are no longer referenced by any active record. This is used for cleanup and garbage collection of unused data. Initialized as empty. } The structure of the primary record stored in the main DataStore for each key. This record contains metadata and a reference (File) to the actual user data.  ","version":null,"tagName":"h3"},{"title":"MigrationStep​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#MigrationStep","content":"&lt;/&gt; interface MigrationStep { name: string-- The unique name of the migration step. apply: (data: {[string]: any}) → {[string]: any}-- The function that transforms the data for this step. } Represents a migration step that can be applied to data when loading it. Each step has a name and an apply function that takes the data as input and returns a modified version of the data.  ","version":null,"tagName":"h3"},{"title":"StoreContext<T>​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#StoreContext<T>","content":"&lt;/&gt; interface StoreContext&lt;T&gt; { name: string-- The name of the store, used for logging and potentially identifying DataStore keys. template: T-- A default template object representing the initial state for new data entries. schema: (value: any) → ( boolean, string? )-- A validation function (like one created by t) used to check if loaded or modified data conforms to the expected structure. Returns true if valid, or false and an error message string if invalid. migrationSteps: {MigrationStep}-- A list of migration steps to apply to data when it's loaded, based on the appliedMigrations field in the DataStoreRecord. Initialized as empty. importLegacyData: ((key: string) → any?)?-- An optional function to load data from a legacy storage system when a key is accessed for the first time in this store. dataStoreService: DataStoreService -- The Roblox DataStoreService instance. memoryStoreService: MemoryStoreService -- The Roblox MemoryStoreService instance. changedCallbacks: {( key: string, newData: T, oldData: T? ) → ()}-- A list of functions to call whenever data for a key is successfully changed. Provides the key, the new data state, and the previous data state (if available). Initialized as empty. logger: Logger-- A Logger instance used for internal logging within the store and its components. onLockLost: ((key: string) → ())?-- An optional callback function triggered if the distributed lock for a key is lost unexpectedly (e.g., due to expiration or external interference). recordStore: DataStore -- The DataStore used to store DataStoreRecord objects. shardStore: DataStore -- The DataStore used to store the actual data shards for large files. txStore: DataStore -- The DataStore used to store transaction status markers (txId keys). lockHashMap: MemoryStoreHashMap -- The MemoryStore HashMap used for managing distributed locks. } Contains all the contextual information and dependencies required for a Store or PlayerStore instance to operate. This includes configuration, service instances, callbacks, and underlying storage objects.  ","version":null,"tagName":"h3"},{"title":"RetryHandle<T>​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#RetryHandle<T>","content":"&lt;/&gt; interface RetryHandle&lt;T&gt; { promise: T-- The Promise representing the asynchronous operation being retried. This promise resolves or rejects based on the outcome of the operation after retries. cancel: () → ()-- A function that can be called to signal cancellation. If called, the retry mechanism will stop further attempts and reject the promise. } A handle returned by retry utility functions like hashMapRetry. It bundles the core Promise with a way to cancel the retry operation. When the cancel function is called, instead of cancelling the Promise itself, the retry mechanism is stopped, and the Promise is rejected with a cancellation error when the next retry attempt is made. ","version":null,"tagName":"h3"},{"title":"PlayerStore","type":0,"sectionRef":"#","url":"/lyra/api/PlayerStore","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#types","content":" ","version":null,"tagName":"h2"},{"title":"PlayerStoreConfig​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#PlayerStoreConfig","content":"&lt;/&gt; interface PlayerStoreConfig { name: string-- The name of the store template: T-- The template data for new keys schema: (value: any) → ( boolean, string? )-- A function to validate data migrationSteps: {MigrationStep}?-- Optional migration steps importLegacyData: ((key: string) → any?)?-- Optional function to import legacy data changedCallbacks: {( key: string, newData: T, oldData: T? ) → ()}?-- Optional callbacks for data changes logCallback: ((logMessage: LogMessage) → ())?-- Optional callback for log messages memoryStoreService: MemoryStoreService? -- Optional MemoryStoreService instance for mocking dataStoreService: DataStoreService? -- Optional DataStoreService instance for mocking } Configuration for creating a new Store. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#functions","content":" ","version":null,"tagName":"h2"},{"title":"createPlayerStore​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#createPlayerStore","content":"&lt;/&gt; PlayerStore.createPlayerStore( config: PlayerStoreConfig&lt;T&gt;-- Configuration for the store ) → PlayerStore&lt;T&gt; Creates a new PlayerStore with the given configuration. Configuration is similar to Store.createStore, but automatically adds player kick handling. local playerStore = PlayerStore.create({ name = &quot;PlayerData&quot;, template = { coins = 0 }, schema = function(data) return typeof(data.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, -- Optional: Runs whenever data changes changedCallbacks = { function(key, newData, oldData) print(key, &quot;changed from&quot;, oldData.coins, &quot;to&quot;, newData.coins) end, }, }) Players will be automatically kicked with an error message if: Their data fails to load The DataStore lock is lost during their session  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#get","content":"&lt;/&gt; PlayerStore:get(player: Player ) → Promise&lt;T&gt;-- Resolves with the player's data Gets the current data for the given player. playerStore:get(player):andThen(function(data) print(player.Name, &quot;has&quot;, data.coins, &quot;coins&quot;) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"getAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:getAsync(player: Player ) → () Syntactic sugar for playerStore:get(player):expect(). See PlayerStore:get  ","version":null,"tagName":"h3"},{"title":"load​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#load","content":"&lt;/&gt; PlayerStore:load(player: Player ) → Promise-- Resolves when data is loaded Loads data for the given player. Must be called before using other methods. playerStore:load(player):andThen(function() print(&quot;Data loaded for&quot;, player.Name) end) CAUTION If loading fails, the player will be kicked from the game. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Load already in progress&quot;\tAnother load is in progress for this player &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"loadAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#loadAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:loadAsync(player: Player ) → () Syntactic sugar for playerStore:load(player):expect(). See PlayerStore:load  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#unload","content":"&lt;/&gt; PlayerStore:unload(player: Player ) → Promise&lt;boolean&gt;-- Resolves when the update is complete, with a boolean indicating success Unloads data for the given player. playerStore:unload(player):andThen(function() print(&quot;Data unloaded for&quot;, player.Name) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"unloadAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#unloadAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:unloadAsync(player: Player ) → () Syntactic sugar for playerStore:unload(player):expect(). See PlayerStore:unload  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#update","content":"&lt;/&gt; PlayerStore:update( player: Player , transformFunction: (data: T) → boolean ) → Promise-- Resolves when the update is complete Updates data for the given player using a transform function. The transform function must return true to commit changes, or false to abort. playerStore:update(player, function(data) if data.coins &lt; 100 then data.coins += 50 return true -- Commit changes end return false -- Don't commit changes end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"updateAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:updateAsync( player: Player , transformFunction: (data: T) → boolean ) → () Syntactic sugar for playerStore:update(player, transformFunction):expect(). See PlayerStore:update  ","version":null,"tagName":"h3"},{"title":"updateImmutable​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#updateImmutable","content":"&lt;/&gt; PlayerStore:updateImmutable( player: Player , transformFunction: (data: T) → T | false ) → Promise-- Resolves when the update is complete Updates data for the given player using a transform function that does not mutate the original data. The transform function must return the new data or false to abort. playerStore:updateImmutable(player, function(data) if data.coins &lt; 100 then return { coins = data.coins + 50 } -- Return new data to commit changes end return false -- Don't commit changes end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"updateImmutableAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#updateImmutableAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:updateImmutableAsync( player: Player , transformFunction: (data: T) → T | false ) → () Syntactic sugar for playerStore:updateImmutable(player, transformFunction):expect(). See PlayerStore:updateImmutable  ","version":null,"tagName":"h3"},{"title":"tx​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#tx","content":"&lt;/&gt; PlayerStore:tx( players: {Player }, transformFunction: (state: {[Player ]: T}) → boolean ) → Promise-- Resolves with true if the transaction was successful, or false if it was aborted. Rejects on error. Performs a transaction across multiple players' data atomically. All players' data must be loaded first. Either all changes apply or none do. playerStore:tx({player1, player2}, function(state) -- Transfer coins between players if state[player1].coins &gt;= 100 then state[player1].coins -= 100 state[player2].coins += 100 return true -- Commit transaction end return false -- Abort transaction end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tOne or more players' data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"txAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#txAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:txAsync( players: {Player }, transformFunction: (state: {[Player ]: T}) → boolean ) → () Syntactic sugar for playerStore:tx(players, transformFunction):expect(). See PlayerStore:tx  ","version":null,"tagName":"h3"},{"title":"txImmutable​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#txImmutable","content":"&lt;/&gt; PlayerStore:txImmutable( players: {Player }, transformFunction: (state: {[Player ]: T}) → {[Player ]: T} | false ) → Promise-- Resolves with true if the transaction was successful, or false if it was aborted. Rejects on error. Performs a transaction across multiple players' data atomically using immutable updates. All players' data must be loaded first. Either all changes apply or none do. playerStore:txImmutable({player1, player2}, function(state) -- Transfer coins between players if state[player1].coins &gt;= 100 then return { [player1] = { coins = state[player1].coins - 100 }, [player2] = { coins = state[player2].coins + 100 }, } -- Commit transaction with new data end return false -- Abort transaction end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tOne or more players' data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"txImmutableAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#txImmutableAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:txImmutableAsync( players: {Player }, transformFunction: (state: {[Player ]: T}) → {[Player ]: T} | false ) → () Syntactic sugar for playerStore:txImmutable(players, transformFunction):expect(). See PlayerStore:txImmutable  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#save","content":"&lt;/&gt; PlayerStore:save(player: Player ) → Promise-- Resolves when the save is complete Forces an immediate save of the given player's data. INFO Data is automatically saved periodically, so manual saves are usually unnecessary. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"saveAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#saveAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:saveAsync(player: Player ) → () Syntactic sugar for playerStore:save(player):expect(). See PlayerStore:save  ","version":null,"tagName":"h3"},{"title":"close​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#close","content":"&lt;/&gt; PlayerStore:close() → Promise-- Resolves when the store is closed Closes the store and unloads all active sessions. The store cannot be used after closing.  ","version":null,"tagName":"h3"},{"title":"closeAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#closeAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:closeAsync() → () Syntactic sugar for playerStore:close():expect(). See PlayerStore:close  ","version":null,"tagName":"h3"},{"title":"peek​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#peek","content":"&lt;/&gt; PlayerStore:peek(userId: number) → Promise&lt;T&gt;-- Resolves with the current data Returns the current data for the given key without loading it into the store. playerStore:peek(userId):andThen(function(data) print(&quot;Current coins:&quot;, data.coins) end)   ","version":null,"tagName":"h3"},{"title":"peekAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#peekAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerStore:peekAsync(userId: number) → () Syntactic sugar for playerStore:peek(userId):expect(). See PlayerStore:peek ","version":null,"tagName":"h3"},{"title":"Data Migrations","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/migrations","content":"","keywords":"","version":"Next"},{"title":"How Migrations Work​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#how-migrations-work","content":" When a player's data is loaded, Lyra:  Checks which migrations have already run for this playerRuns any new migrations in orderRecords which migrations were appliedValidates the final data against your schema  This means each migration runs exactly once per player, even if they join multiple times or on different servers.  Migration Order Migrations always run in the order they're defined. Once published, this order is permanent and should never be changed. In the snippet below, addLevel will always run after addSettings.  ","version":"Next","tagName":"h2"},{"title":"Adding New Fields​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#adding-new-fields","content":" When adding new fields to your data, follow these steps:  Add the field to your template with its default valueAdd the field to your schema to define its type/validationCreate a migration step using addFields to add it to existing data  For example:  -- Step 1: Add to template local template = { coins = 0, -- Existing field gems = 0, -- New field } -- Step 2: Add to schema local schema = { coins = t.number, gems = t.number, -- New field } -- Step 3: Add migration local store = Lyra.createPlayerStore({ template = template, schema = schema, migrationSteps = { Lyra.MigrationStep.addFields(&quot;addGems&quot;, { gems = 0, }), }, })   ","version":"Next","tagName":"h2"},{"title":"Basic Migrations​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#basic-migrations","content":" The simplest migration is adding new fields:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, migrationSteps = { Lyra.MigrationStep.addFields(&quot;addSettings&quot;, { settings = { music = true, sfx = true, } }), Lyra.MigrationStep.addFields(&quot;addLevel&quot;, { level = 1, }), }, })   Migration Names Are Permanent Migration names (like &quot;addSettings&quot;) are permanent and help Lyra track which migrations have run. Choose descriptive names that indicate what the migration does, as you can't change them later.  ","version":"Next","tagName":"h2"},{"title":"Transform Steps​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#transform-steps","content":" For more complex changes, use transform steps:  migrationSteps = { Lyra.MigrationStep.transform(&quot;inventoryToItems&quot;, function(data) -- Convert simple inventory list to detailed items data.items = {} for _, item in data.inventory do table.insert(data.items, { id = item, acquired = os.time(), }) end data.inventory = nil return data end), }   ","version":"Next","tagName":"h2"},{"title":"Migration Return Values​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#migration-return-values","content":" Each migration step must return data that will eventually match your schema after all migrations run. This means:  Intermediate migrations can return data in any formatThe final state after all migrations must match your schemaLyra validates the final data against your schema after all migrations complete  For example, this is valid even though the intermediate state doesn't match the final schema:  migrationSteps = { -- First migration returns data that doesn't match final schema Lyra.MigrationStep.transform(&quot;step1&quot;, function(data) return { temporaryField = data.oldField, } }), -- Second migration transforms it to match schema Lyra.MigrationStep.transform(&quot;step2&quot;, function(data) return { newField = data.temporaryField, } }), }   ","version":"Next","tagName":"h2"},{"title":"Multiple Steps​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#multiple-steps","content":" You can chain multiple migration steps. They'll run in the order they're defined, from top to bottom:  migrationSteps = { -- Add new currency Lyra.MigrationStep.addFields(&quot;addGems&quot;, { gems = 0, }), -- Restructure inventory Lyra.MigrationStep.transform(&quot;inventoryV2&quot;, function(data) data.inventory = { items = data.inventory, maxSlots = 20, } return data end), }   Migration Order Is Critical Migrations always run in the order they're defined. This order becomes permanent once published - you can't change it later. If a new migration needs data from an older one, add it after the existing migrations.  ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#best-practices","content":" When working with migrations:  Plan carefully - Once published, migrations can't be changedKeep migrations simple - One logical change per stepTest thoroughly - Migrations run once and can't be undone  ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#see-also","content":" Getting Started for basic Lyra usageDebugging for troubleshooting migrationsCore Concepts for understanding how Lyra works ","version":"Next","tagName":"h2"},{"title":"Network Updates","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/networking","content":"","keywords":"","version":"Next"},{"title":"Understanding Change Callbacks​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#understanding-change-callbacks","content":" Change callbacks are functions that run whenever data changes, whether through updates or transactions. They receive three parameters:  The key (player UserId as a string)The new data (frozen to prevent mutations)The previous data (if any, also frozen)  Here's a basic example:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Network = require(ReplicatedStorage.Network) local function syncWithClient(key: string, newData, oldData) local player = Players:GetPlayerByUserId(tonumber(key)) if not player then return end if oldData == nil then -- First time data is loaded Network.PlayerData:FireClient(player, newData) return end -- Send only changed data local changes = {} if newData.coins ~= oldData.coins then changes.coins = newData.coins end if not Tables.deepEquals(newData.inventory, oldData.inventory) then changes.inventory = newData.inventory end -- Send changes to client Network.PlayerData:FireClient(player, changes) end local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, changedCallbacks = { syncWithClient }, })   tip Compare old and new data to send only changed values, reducing network traffic.  ","version":"Next","tagName":"h2"},{"title":"Multiple Callbacks​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#multiple-callbacks","content":" While changedCallbacks are primarily used for networking, you can register multiple callbacks if needed. Each callback receives the same read-only data:  local store = Lyra.createPlayerStore({ changedCallbacks = { -- Keep clients in sync syncWithClient, -- Log changes for debugging function(key, newData, oldData) print(`Player {key} data changed`) end, }, })   ","version":"Next","tagName":"h2"},{"title":"Data Safety​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#data-safety","content":" Change callbacks receive frozen copies of the data. This means the data is read-only and cannot be modified:  local function callback(key, newData, oldData) -- ❌ This will error - data is frozen newData.coins = 100 end   ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#see-also","content":" Core Concepts for understanding data managementGetting Started for basic setup ","version":"Next","tagName":"h2"},{"title":"Store","type":0,"sectionRef":"#","url":"/lyra/api/Store","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#types","content":" ","version":null,"tagName":"h2"},{"title":"StoreConfig​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#StoreConfig","content":"&lt;/&gt; interface StoreConfig { name: string-- A unique name for this store (e.g., &quot;PlayerDataProd&quot;). Used for logging and deriving DataStore/MemoryStore keys. template: T-- A deep copyable Luau table/value representing the default state for a new key. schema: (value: any) → ( boolean, string? )-- A validation function (e.g., created with t) that checks if data conforms to the expected structure. Returns true if valid, or false and an error message if invalid. migrationSteps: {Types.MigrationStep}?-- An optional ordered list of migration steps to apply to data loaded from the DataStore if its schema is older than the current version. See Migrations.luau. importLegacyData: ((key: string) → any?)?-- An optional function to load data from a different, legacy storage system when a key is accessed for the first time and doesn't exist in this store. dataStoreService: DataStoreService? -- An optional override for the Roblox DataStoreService. Useful for testing or custom storage implementations. Defaults to game:GetService(&quot;DataStoreService&quot;). memoryStoreService: MemoryStoreService? -- An optional override for the Roblox MemoryStoreService. Useful for testing. Defaults to game:GetService(&quot;MemoryStoreService&quot;). useMock: boolean?-- If true (and running in Studio), uses mock in-memory implementations of DataStoreService and MemoryStoreService instead of the actual Roblox services. Useful for testing in a controlled environment. Defaults to false. changedCallbacks: {( key: string, newData: T, oldData: T? ) → ()}?-- An optional list of functions called after data for a key has been successfully updated. Provides the key, the new data state, and the previous data state (if available). logCallback: ((logMessage: Log.LogMessage) → ())?-- A function to receive log messages generated by this Store instance and its components. If omitted, logs are discarded. See Log. onLockLost: ((key: string) → ())?-- An optional callback function triggered if the distributed lock for a key's session is lost unexpectedly (e.g., due to expiration or external interference). This usually indicates the session is no longer safe to use. } Configuration options for creating a new Store instance using createStore. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#functions","content":" ","version":null,"tagName":"h2"},{"title":"createStore​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#createStore","content":"&lt;/&gt; Store.createStore( config: StoreConfig&lt;T&gt;-- Configuration options for the store. ) → Store&lt;T&gt;-- A new, initialized Store instance. Factory function to create a new Store instance. Initializes the store context, sets up DataStore and MemoryStore connections (real or mock), validates the template schema, and returns the configured Store object.  ","version":null,"tagName":"h3"},{"title":"txInternal​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#txInternal","content":"&lt;/&gt; Store.txInternal( self: Store&lt;T&gt;, keys: {string},-- An array of keys involved in the transaction. transformFunction: ((state: {[string]: any}) → boolean) | ((state: {[string]: any}) → {[string]: any} | false),-- A function that receives the current state of all keys and, depending on immutable, either modifies it directly (mutable) and returns true to commit, or returns a new state (immutable) to commit. Must return false to abort the transaction. immutable: boolean ) → Promise-- Resolves with true if the transaction was successful, or false if it was aborted. Rejects on error. Internal helper to perform transaction logic on multiple keys. Handles acquiring locks, validating state, and committing changes atomically via a two-phase commit process. Supports both immutable and mutable transactions, where immutable controls whether the data passed to the transformFunction is a deep copy (mutable) or a reference to the canonical, frozen data (immutable). Implementation Details: Uses PromiseQueue.multiQueueAdd to ensure the transform function only runs when all involved session queues are ready. Uses a temporary txLockPromise on sessions to block concurrent update calls while the transaction logic is executing. Performs a two-phase commit using a transaction marker in the txStore: Write false to txStore under a unique txId. Update all primary recordStore entries with the new data and txId. If successful, remove the txId entry from txStore. If any step fails, attempts to revert changes by rewriting records without the txId and removing the txId marker. Uses JsonPatch to calculate differences for efficient storage in TxInfo. Propagates DataStore errors encountered during the commit or revert phases. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf any key in the `keys` array has not been loaded. &quot;Key is already locked by another transaction&quot;\tIf any key is already involved in an ongoing `tx`. &quot;Key is closed&quot;\tIf any involved session has been closed (e.g., due to lock loss). &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data for any key after transformation fails the schema check. &quot;Keys changed in transaction&quot;\tIf the `transformFunction` attempts to add or remove keys from the state table it receives.  ","version":null,"tagName":"h3"},{"title":"load​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#load","content":"&lt;/&gt; Store:load( key: string,-- The unique identifier for the data to load (e.g., &quot;player_123&quot;). userIds: {number}?-- Optional list of UserIDs for DataStore key tagging. ) → Promise-- Resolves when the data is successfully loaded and the session is ready, or rejects on error. Acquires a distributed lock, loads data for the given key into memory, and establishes a Session object to manage the key's state. This must be called before performing operations like get, update, or save on the key. It handles concurrent load attempts and waits for any ongoing unload operations to complete first. Propagates errors from Session.load (e.g., lock acquisition failure, DataStore errors). ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Load already in progress&quot;\tIf `load` is called again for the same key while a previous load is still running. &quot;Store is closed&quot;\tIf the store instance has been closed via `close()`.  ","version":null,"tagName":"h3"},{"title":"loadAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#loadAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:loadAsync( key: string,-- The unique identifier for the data to load. userIds: {number}?-- Optional list of UserIDs for DataStore key tagging. ) → () Synchronous wrapper for Store:load. Waits for the Promise to settle. Throws an error if the load fails or is cancelled. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the load process.  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#unload","content":"&lt;/&gt; Store:unload( key: string-- The unique identifier for the data to unload. ) → Promise-- Resolves when the data is successfully unloaded, or rejects on error. Unloads data for the given key from memory, saves any pending changes, releases the distributed lock, and ends the session. Propagates errors from Session:unload (e.g., save failures). ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Store is closed&quot;\tIf the store instance has been closed.  ","version":null,"tagName":"h3"},{"title":"unloadAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#unloadAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:unloadAsync( key: string-- The unique identifier for the data to unload. ) → () Synchronous wrapper for Store:unload. Waits for the Promise to settle. Throws an error if the unload fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the unload process.  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#get","content":"&lt;/&gt; Store:get( key: string-- The key whose data to retrieve. ) → Promise&lt;T&gt;-- Resolves with the current data object (potentially a deep copy). Gets the current, in-memory data state for the given key. Requires the key to be loaded first via load(). If the key is still loading, this will wait for it to finish. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store has been closed.  ","version":null,"tagName":"h3"},{"title":"getAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:getAsync( key: string-- The key whose data to retrieve. ) → T-- The current data object. Synchronous wrapper for Store:get. Waits for the Promise to settle. Throws an error if getting the data fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store has been closed.  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#update","content":"&lt;/&gt; Store:update( key: string,-- The key whose data to update. transformFunction: (data: T) → boolean-- A function that receives the current data and returns true to commit changes or false to abort. ) → Promise&lt;boolean&gt;-- Resolves with true if the transform function returned true and the update was successfully queued, or false if the transform function returned false. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation. Applies changes to the data for a given key using a transform function. The transformFunction receives the current data and can modify it directly. It must return true to indicate that changes were made and should be saved, or false to abort the update without saving. Changes are applied optimistically to the in-memory state first and then queued for saving to the DataStore. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data returned by `transformFunction` does not pass the store's schema check.  ","version":null,"tagName":"h3"},{"title":"updateAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:updateAsync( key: string,-- The key whose data to update. transformFunction: (data: T) → boolean-- The transformation function. ) → boolean-- Returns the boolean value returned by the transformFunction. Synchronous wrapper for Store:update. Waits for the Promise to settle. Throws an error if the update fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data returned by `transformFunction` does not pass the store's schema check.  ","version":null,"tagName":"h3"},{"title":"updateImmutable​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#updateImmutable","content":"&lt;/&gt; Store:updateImmutable( key: string,-- The key whose data to update. transformFunction: (data: T) → T | false-- A function that receives the current data and returns a new copy of the data with changes to commit changes, or false to abort. ) → Promise&lt;boolean&gt;-- Resolves with true if the transform function committed and the update was successfully queued, or false if the transform function returned false. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation. Applies changes to the data for a given key using a transform function, with immutable copy-on-write semantics. The transformFunction receives the current data but frozen (immutable), and cannot modify it directly. Instead, it should return new data that reflects the desired changes. Otherwise it should return false to abort the update without saving. Changes are applied optimistically to the in-memory state first and then queued for saving to the DataStore. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data returned by `transformFunction` does not pass the store's schema check.  ","version":null,"tagName":"h3"},{"title":"updateImmutableAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#updateImmutableAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:updateImmutableAsync( key: string,-- The key whose data to update. transformFunction: (data: T) → T | false-- The transformation function. ) → boolean-- Returns true if the update was successful, or false if the transform function returned false. Synchronous wrapper for Store:updateImmutable. Waits for the Promise to settle. Throws an error if the update fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data returned by `transformFunction` does not pass the store's schema check.  ","version":null,"tagName":"h3"},{"title":"tx​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#tx","content":"&lt;/&gt; Store:tx( keys: {string},-- An array of keys involved in the transaction. transformFunction: (state: {[string]: T}) → boolean-- The transformation function. ) → Promise&lt;boolean&gt;-- Resolves with true if the transaction was successful, or false if it was aborted. Rejects on error. Performs an atomic transaction across multiple keys. Requires the keys to be loaded first via load(). The transformFunction is called with the current state of all involved keys and must return true to commit changes or false to abort. Propagates errors from the transaction process, including DataStore errors, schema validation failures, and key loading issues. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf any key in the `keys` array has not been loaded. &quot;Key is already locked by another transaction&quot;\tIf any key is already involved in an ongoing `tx`. &quot;Key is closed&quot;\tIf any involved session has been closed (e.g., due to lock loss). &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data for any key after transformation fails the schema check. &quot;Keys changed in transaction&quot;\tIf the `transformFunction` attempts to add or remove keys from the state table it receives.  ","version":null,"tagName":"h3"},{"title":"txAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#txAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:txAsync( keys: {string},-- An array of keys involved in the transaction. transformFunction: (state: {[string]: T}) → boolean-- The transformation function. ) → () Synchronous wrapper for Store:tx. Waits for the Promise to settle. Throws an error if the transaction fails or is aborted. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the transaction.  ","version":null,"tagName":"h3"},{"title":"txImmutable​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#txImmutable","content":"&lt;/&gt; Store:txImmutable( keys: {string},-- An array of keys involved in the transaction. transformFunction: (state: {[string]: T}) → {[string]: T} | false-- The transformation function. ) → Promise&lt;boolean&gt;-- Resolves with true if the transaction was successful, or false if it was aborted. Rejects on error. Performs an atomic transaction across multiple keys with immutable, copy-on-write semantics. The data passed to the function is frozen and cannot be modified directly. Instead, the function should return a new table with the desired changes. Requires the keys to be loaded first via load(). The transformFunction is called with the current state of all involved keys and must return the new state to commit or false to abort. Propagates errors from the transaction process, including DataStore errors, schema validation failures, and key loading issues. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf any key in the `keys` array has not been loaded. &quot;Key is already locked by another transaction&quot;\tIf any key is already involved in an ongoing `tx`. &quot;Key is closed&quot;\tIf any involved session has been closed (e.g., due to lock loss). &quot;Store is closed&quot;\tIf the store instance has been closed. &quot;Schema validation failed&quot;\tIf the data for any key after transformation fails the schema check. &quot;Keys changed in transaction&quot;\tIf the `transformFunction` attempts to add or remove keys from the state table it receives.  ","version":null,"tagName":"h3"},{"title":"txImmutableAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#txImmutableAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:txImmutableAsync( keys: {string},-- An array of keys involved in the transaction. transformFunction: (state: {[string]: T}) → {[string]: T} | false-- The transformation function. ) → boolean Synchronous wrapper for Store:txImmutable. Waits for the Promise to settle. Throws an error if the transaction fails or is aborted. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the transaction.  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#save","content":"&lt;/&gt; Store:save( key: string-- The key whose data to save. ) → Promise-- Resolves when the save operation completes successfully, rejects on error. Forces an immediate save of the given key's current in-memory data state to the DataStore. NOTE Data is automatically saved periodically by the Session's autosave mechanism. Manual saves are typically only needed in specific scenarios like processing developer product purchases (MarketplaceService.ProcessReceipt) where immediate persistence is crucial before granting benefits. Propagates errors from Session:save (e.g., DataStore write errors). ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tIf `load()` has not been successfully called for this key. &quot;Store is closed&quot;\tIf the store instance has been closed.  ","version":null,"tagName":"h3"},{"title":"saveAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#saveAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:saveAsync( key: string-- The key whose data to save. ) → () Synchronous wrapper for Store:save. Waits for the Promise to settle. Throws an error if the save fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the save operation.  ","version":null,"tagName":"h3"},{"title":"close​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#close","content":"&lt;/&gt; Store:close() → Promise-- Resolves when all sessions have attempted to unload, or rejects if any session encountered an error during its unload process (errors are aggregated). Closes the store, gracefully unloading all active sessions. Attempts to save any pending changes for all loaded keys before releasing locks and removing sessions from memory. The store instance becomes unusable as soon as this is called.  ","version":null,"tagName":"h3"},{"title":"closeAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#closeAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:closeAsync() → () Synchronous wrapper for Store:close. Waits for the Promise to settle. Throws an error if closing fails (i.e., if any session failed to unload). ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows an error (potentially a table of errors) if closing fails.  ","version":null,"tagName":"h3"},{"title":"peek​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#peek","content":"&lt;/&gt; Store:peek( key: string-- The key whose data to peek at. ) → Promise&lt;T?&gt;-- Resolves with the data object, or nil if the key doesn't exist. Rejects on DataStore errors. Reads the current data for the given key directly from the DataStore, bypassing the session cache and locking mechanism. This provides a snapshot of the last saved state but does not load the key into an active session. Useful for inspecting data without acquiring a lock. Handles potential sharding and transaction status automatically. Propagates DataStore errors from underlying reads.  ","version":null,"tagName":"h3"},{"title":"peekAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#peekAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:peekAsync( key: string-- The key whose data to peek at. ) → T?-- The data object, or nil if the key doesn't exist. Synchronous wrapper for Store:peek. Waits for the Promise to settle. Returns the data for the key if it exists. Throws on any errors from underlying DataStore operations. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tMay throw errors from underlying DataStore operations.  ","version":null,"tagName":"h3"},{"title":"probeLockActive​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#probeLockActive","content":"&lt;/&gt; Store:probeLockActive( key: string-- The key to check the lock status for. ) → Promise&lt;boolean&gt;-- Resolves with true if a lock is active, false otherwise. Rejects on MemoryStore errors. Checks if a distributed lock is currently active for the given key in MemoryStore. Propagates errors from Locks.probeLockActive.  ","version":null,"tagName":"h3"},{"title":"probeLockActiveAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#probeLockActiveAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:probeLockActiveAsync( key: string-- The key to check the lock status for. ) → boolean-- true if a lock is active, false otherwise. Synchronous wrapper for Store:probeLockActive. Waits for the Promise to settle. Throws an error if the check fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the probe operation.  ","version":null,"tagName":"h3"},{"title":"listVersions​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#listVersions","content":"&lt;/&gt; Store:listVersions( params: ListVersionParams-- Parameters specifying the key, sorting, date range, and page size. ) → Promise&lt;DataStoreVersionPages &gt;-- Resolves with an iterator object (DataStoreVersionPages) that can be used to fetch pages of version history. Rejects on DataStore errors. Lists historical versions of the data for a given key using DataStore versioning. Propagates errors from DataStore:ListVersionsAsync.  ","version":null,"tagName":"h3"},{"title":"listVersionsAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#listVersionsAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:listVersionsAsync( params: ListVersionParams-- Parameters for listing versions. ) → DataStoreVersionPages -- An iterator for version history. Synchronous wrapper for Store:listVersions. Waits for the Promise to settle. Throws an error if listing versions fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the list operation.  ","version":null,"tagName":"h3"},{"title":"readVersion​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#readVersion","content":"&lt;/&gt; Store:readVersion( key: string,-- The key whose version to read. version: string-- The specific version ID (obtained from listVersions). ) → Promise&lt;( T, DataStoreKeyInfo )&gt;-- Resolves with the data object (T) and the DataStoreKeyInfo for that version. Rejects if the version doesn't exist or on DataStore/read errors. Reads the data content of a specific historical version for a given key. Propagates DataStore errors from underlying reads. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Record not found&quot;\tIf the specified version doesn't exist.  ","version":null,"tagName":"h3"},{"title":"readVersionAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#readVersionAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Store:readVersionAsync( key: string,-- The key whose version to read. version: string-- The specific version ID. ) → ( T,-- The data object for the specified version. DataStoreKeyInfo -- The key info for the specified version. ) Synchronous wrapper for Store:readVersion. Waits for the Promise to settle. Throws an error if reading the version fails. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescriptionany\tThrows any error encountered during the read operation. ","version":null,"tagName":"h3"},{"title":"State Management and Lyra","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/state-management","content":"","keywords":"","version":"Next"},{"title":"Lyra as the Source of Truth​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#lyra-as-the-source-of-truth","content":" When building games with Lyra, it's important to understand that Lyra is designed to be the source of truth for your data. This design choice enables Lyra to provide strong guarantees about data consistency and integrity.  ","version":"Next","tagName":"h2"},{"title":"Common Integration Patterns​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#common-integration-patterns","content":" Some developers use state management libraries like Reflex, Charm, or custom solutions alongside Lyra. When integrating these tools, there are two common approaches:  Pattern 1: External State as Source of Truth (Not Recommended)​  -- External state is the primary source of truth function giveCoins(player, amount) -- Update external state first gameState.players[player.UserId].coins += amount -- Then flush to Lyra as a secondary step store:updateAsync(player.UserId, function(data) data.coins = gameState.players[player.UserId].coins return true end) end   Pattern 2: Lyra as Source of Truth (Recommended)​  -- Lyra is the primary source of truth function giveCoins(player, amount) -- Update Lyra first store:updateAsync(player.UserId, function(data) data.coins += amount return true end) -- Other systems can derive from Lyra through changedCallbacks end   ","version":"Next","tagName":"h3"},{"title":"Why Lyra Should Be the Source of Truth​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#why-lyra-should-be-the-source-of-truth","content":" When Lyra isn't the primary source of truth, several key features become compromised:  Atomicity: Lyra's updates are atomic - they either succeed completely or fail entirely. This guarantee is lost when changes originate elsewhere. Transactions: Lyra's transactions allow updating multiple players' data atomically - a feature that requires Lyra to control the data flow. Data Consistency: When external state and Lyra diverge (e.g., if a Lyra update fails), reconciling the differences becomes complex. Schema Validation: Lyra validates data against your schema during updates, catching issues early. When changes happen outside Lyra, these validations are bypassed, leading to potential data corruption.  ","version":"Next","tagName":"h3"},{"title":"The Technical Reason​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#the-technical-reason","content":" Behind the scenes, Lyra maintains data integrity through a carefully orchestrated system:  Updates and transactions are queued and processed in sequenceTransactions require waiting for some DataStore calls to guarantee atomicityDuring a transaction, updates to affected keys are paused until the transaction completesThis is necessary because changes from transactions are only considered valid if all DataStore operations succeedIf any operation fails, Lyra discards all pending changes to maintain consistency  If external systems modify data at the same time Lyra is processing a transaction, this careful balance breaks down. The only way to handle such conflicts would require complex rollback mechanisms that impose significant constraints on your code structure.  By making Lyra the source of truth, you get robust data integrity without these complications.  ","version":"Next","tagName":"h3"},{"title":"Practical Integration Strategies​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#practical-integration-strategies","content":" If you're using a state management library alongside Lyra, consider these approaches:  ","version":"Next","tagName":"h2"},{"title":"For Game Systems and Services​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#for-game-systems-and-services","content":" Use your state management library for ephemeral game state, while letting Lyra handle persistent player data:  -- Lyra handles persistent data store:updateAsync(player.UserId, function(data) data.questProgress.questId = 5 data.questProgress.stepsCompleted += 1 return true end) -- Game systems can track active state separately gameState.activeQuests[player.UserId] = { questId = 5, timeRemaining = 600, location = workspace.QuestLocations.Cave }   ","version":"Next","tagName":"h3"},{"title":"Deriving State from Lyra​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#deriving-state-from-lyra","content":" Let Lyra drive updates to the rest of your code through callbacks:  -- When Lyra data changes, update external state changedCallbacks = { function(key, newData, oldData) local playerId = tonumber(key) gameState.players[playerId][key] = newData[key] end }   ","version":"Next","tagName":"h3"},{"title":"Common Questions​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#common-questions","content":" ","version":"Next","tagName":"h2"},{"title":"\"How do I handle complex state that isn't just player data?\"​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#how-do-i-handle-complex-state-that-isnt-just-player-data","content":" Lyra is primarily designed for persistent player data. For state that doesn't need persistence, it's fine to use other state management approaches:  -- State that doesn't need persistence local gameState = { currentRound = 1, roundStartTime = os.time(), activePlayers = {}, } -- Player data that needs persistence uses Lyra function playerCompletedRound(player) local score = gameState.roundScores[player.UserId] or 0 store:updateAsync(player.UserId, function(data) data.roundsCompleted += 1 data.totalScore += score return true end) end   ","version":"Next","tagName":"h3"},{"title":"\"What about systems that need to react to data changes?\"​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#what-about-systems-that-need-to-react-to-data-changes","content":" You can use Lyra's changedCallbacks to notify other systems when data changes:  -- Set up a badge award system that reacts to data changes changedCallbacks = { function(key, newData, oldData) if oldData == nil then return end local playerId = tonumber(key) -- Check if player reached a milestone if oldData.coins &lt; 1000 and newData.coins &gt;= 1000 { BadgeService.awardBadge(playerId, BADGES.COIN_COLLECTOR) } -- Check if player completed all quests if #oldData.completedQuests &lt; 10 and #newData.completedQuests &gt;= 10 { BadgeService.awardBadge(playerId, BADGES.QUEST_MASTER) } end }   ","version":"Next","tagName":"h3"},{"title":"Recap​","type":1,"pageTitle":"State Management and Lyra","url":"/lyra/docs/advanced/state-management#recap","content":" While it might be tempting to use another state management system as your primary source of truth, doing so limits Lyra's ability to provide its core benefits. By keeping Lyra as the source of truth for persistent data, you'll build more robust games with fewer data-related issues. ","version":"Next","tagName":"h2"},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/lyra/docs/core-concepts","content":"","keywords":"","version":"Next"},{"title":"Understanding Sessions​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#understanding-sessions","content":" When a player joins your game, you need a way to work with their data. A session is Lyra's way of managing this connection between your game and a player's saved data.  Sessions utilize 'session locking' to keep data safe. When you load a player's data, Lyra 'locks' it, which gives your server exclusive access to that data. This is crucial - without session locking, multiple servers might try to modify the same player's data simultaneously, leading to race conditions and lost data.  Here's how you work with sessions:  Players.PlayerAdded:Connect(function(player) -- Establish exclusive access to the player's data store:loadAsync(player) end) Players.PlayerRemoving:Connect(function(player) -- Release the lock and save any pending changes store:unloadAsync(player) end)   Loading a session is always your first step. Any attempts to access or modify data before establishing a session will fail, as Lyra needs to ensure exclusive access before allowing operations.  ","version":"Next","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#working-with-data","content":" Once you have a session, you can start working with the player's data. Lyra provides a structured way to make changes through updates.  An update is a function that receives the current data and can modify it mutably. The function must return true to commit the changes, providing an atomic way to perform conditional updates:  store:updateAsync(player, function(data) if data.coins &lt; itemPrice then return false -- Abort the update end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end)   This pattern enables you to encapsulate your game's logic within updates while ensuring data consistency. The update either succeeds completely or fails entirely - there's no possibility of partial changes.  Don't Yield! Lyra enforces that updates are synchronous and non-blocking - if you yield inside the update function, it will error and abort the operation.  ","version":"Next","tagName":"h2"},{"title":"Automatic Data Persistence​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#automatic-data-persistence","content":" Lyra takes care of saving your data automatically. Every 5 minutes, it performs an autosave operation for all active sessions, ensuring your players' progress is regularly persisted to DataStore without any manual intervention required.  To ensure all data is properly saved when the game shuts down, you must call store:closeAsync() inside BindToClose. Lyra doesn't do this for you in case you need to do anything before calling it (usually not):  game:BindToClose(function() store:closeAsync() end)   ","version":"Next","tagName":"h2"},{"title":"Handling Multiple Players​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#handling-multiple-players","content":" Sometimes you need to coordinate changes across multiple players, like in a trading system.  If you update each player individually, there's no guarantee that one player's changes will succeed while the other's fail - imagine a server crashing at exactly the right moment.  This is where transactions come in.  A transaction lets you modify multiple players' data atomically. Either all the changes succeed, or none of them do. This is crucial for maintaining data consistency:  store:txAsync({player1, player2}, function(state) local item = table.remove(state[player1].inventory, 1) if not item then return false -- Abort the transaction end table.insert(state[player2].inventory, item) return true end)   The transaction ensures the atomicity of multi-player operations. You'll never end up in a state where an item has been removed from one player but not added to another, which is essential for maintaining the integrity of your game's economy.  ","version":"Next","tagName":"h2"},{"title":"Data Validation​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#data-validation","content":" Data validation in Lyra works through schemas. When you create a store, you define what valid data looks like:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = { coins = 0, inventory = {}, }, schema = t.strictInterface({ coins = t.number, inventory = t.table, }), })   Lyra enforces this schema on every operation, creating a safe boundary between your game logic and DataStores. If an operation would result in invalid data, Lyra rejects it before it can be saved.  tip We recommend using 't', a Runtime Typechecker for Roblox for defining schemas!  ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#next-steps","content":" Now that you understand the core concepts, you might want to:  Learn about migrations for updating your data formatExplore debugging for troubleshootingSee how to handle network updates ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/lyra/docs/getting-started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#installation","content":" Add Lyra to your wally.toml:  Lyra = &quot;paradoxum-games/lyra@0.6.0&quot;   tip If you're new to Wally, check out the Wally installation guide.  ","version":"Next","tagName":"h2"},{"title":"Basic Setup​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#basic-setup","content":" Here's how to set up Lyra with a simple data structure:  local Players = game:GetService(&quot;Players&quot;) local Lyra = require(path.to.Lyra) -- Define your data template local template = { coins = 0, inventory = {}, } -- Create schema to validate data local schema = t.strictInterface({ coins = t.number, inventory = t.table, }) -- Create the store local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, }) -- Load data when players join Players.PlayerAdded:Connect(function(player) store:loadAsync(player) end) -- Save and clean up when they leave Players.PlayerRemoving:Connect(function(player) store:unloadAsync(player) end) -- Ensure data is saved when the game closes game:BindToClose(function() store:closeAsync() end)   ","version":"Next","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#working-with-data","content":" ","version":"Next","tagName":"h2"},{"title":"Reading Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#reading-data","content":" You can read player data, but remember that it might change between reads:  -- ⚠️ Only use this data for reading -- Don't save it for later use local data = store:getAsync(player) print(`{player.Name} has {data.coins} coins`)   ","version":"Next","tagName":"h3"},{"title":"Modifying Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#modifying-data","content":" Always modify data through update functions:  -- Simple update store:updateAsync(player, function(data) data.coins += 100 return true end) -- Conditional update store:updateAsync(player, function(data) if data.coins &lt; itemPrice then return false -- Abort the update end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end)   ","version":"Next","tagName":"h3"},{"title":"Trading Between Players​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#trading-between-players","content":" Use transactions for operations involving multiple players:  store:txAsync({player1, player2}, function(state) -- Transfer coins if state[player1].coins &lt; amount then return false -- Abort if not enough coins end state[player1].coins -= amount state[player2].coins += amount return true end)   ","version":"Next","tagName":"h3"},{"title":"Importing Existing Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#importing-existing-data","content":" If you're migrating from another DataStore library, you can import your existing data:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, importLegacyData = function(key) local success, data = pcall(function() return YourCurrentSystem.getData(key) end) if not success then error(&quot;Failed to reach data system&quot;) -- Player will be kicked and can retry end if data ~= nil then return data -- Return existing data to import end return nil -- Return nil for new players to use template end, })   ","version":"Next","tagName":"h2"},{"title":"ProcessReceipt Example​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#processreceipt-example","content":" Here's an example of how you would use Lyra in ProcessReceipt:  local ProductCallbacks = { [12345] = function(player, receiptInfo, data) data.coins += 100 return true end, } local function processReceipt(receiptInfo) local player = Players:GetPlayerByUserId(receiptInfo.PlayerId) if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end local productCallback = ProductCallbacks[receiptInfo.ProductId] if not productCallback then return Enum.ProductPurchaseDecision.NotProcessedYet end local ok, result = pcall(function() store:updateAsync(player, function(data) -- Assuming you have 'purchaseHistory' in your template and schema: if table.find(data.purchaseHistory, receiptInfo.PurchaseId) then return false -- Prevent duplicate purchases end table.insert(data.purchaseHistory, 1, receiptInfo.PurchaseId) for i = 1000, #data.purchaseHistory do data.purchaseHistory[i] = nil -- Remove old purchases end return productCallback(player, receiptInfo, data) end) store:saveAsync(player) end) if not ok then warn(`ProcessReceipt failed: {result}`) return Enum.ProductPurchaseDecision.NotProcessedYet end return Enum.ProductPurchaseDecision.PurchaseGranted end   ","version":"Next","tagName":"h2"},{"title":"Promise-based API​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#promise-based-api","content":" Lyra also offers a Promise-based API:  store:update(player, function(data) data.coins -= itemPrice data.inventory.weapon = &quot;starter_sword&quot; return true end):andThen(function() print(&quot;Purchase successful!&quot;) end):catch(function(err) print(`Purchase failed: {err}`) end)   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#next-steps","content":" Now that you've got the basics down, check out:  Core Concepts for a deeper understandingData Migrations for updating data structureNetwork Updates for client synchronizationDebugging for troubleshooting ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/lyra/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#features","content":" Transactions - A powerful tool to implement features like trading, while making bugs like item duplication impossibleSession Locking - Prevents common bugs that lead to corruption and data lossValidation - Ensures your data is always in a consistent stateAuto-Sharding - Handles large data by automatically splitting across multiple DataStore keysMigrations - Update your data format without breaking existing savesDrop-in - Import your existing data and switch over seamlessly  ","version":"Next","tagName":"h2"},{"title":"Quick Example​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#quick-example","content":" Here's what using Lyra looks like:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = { coins = 0, inventory = {}, }, schema = t.strictInterface({ coins = t.number, inventory = t.table, }), }) -- Load data when players join Players.PlayerAdded:Connect(function(player) store:loadAsync(player) end) -- Safe updates with validation store:updateAsync(player, function(data) if data.coins &lt; itemPrice then return false -- Abort if can't afford end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end) -- Atomic trades between players store:txAsync({player1, player2}, function(state) -- Either both changes happen or neither does state[player1].coins -= 100 state[player2].coins += 100 return true end)   Avoid Stale Data Always modify data through update functions. Never use data from a previous :get() call: -- 🚫 Don't do this: local oldData = store:getAsync(player) store:updateAsync(player, function(newData) if not oldData.claimedDailyReward then -- This data might be stale! return false end newData.coins += 500 newData.claimedDailyReward = true return true end) -- ✅ Do this instead: store:updateAsync(player, function(data) if not data.claimedDailyReward then -- This data is always current return false end data.coins += 500 data.claimedDailyReward = true return true end)   ","version":"Next","tagName":"h2"},{"title":"Importing Existing Data​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#importing-existing-data","content":" When switching to Lyra, you can bring your existing data:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, importLegacyData = function(key) local success, data = pcall(function() return YourCurrentSystem.getData(key) end) if not success then -- If there's an error, Lyra will kick the player and prompt them -- to rejoin to try again. error(&quot;Failed to reach data system&quot;) end if data ~= nil then return data -- Return existing data to import end return nil -- Return nil for new players to use template end, })   ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#installation","content":" Add to your wally.toml:  Lyra = &quot;paradoxum-games/lyra@0.6.0&quot;   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#next-steps","content":" Check out Getting Started for a complete setup guideRead Core Concepts to understand how Lyra worksSee the Advanced Features section for migration guides and state management tips ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}