{"searchDocs":[{"title":"Types","type":0,"sectionRef":"#","url":"/api/Types","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Types","url":"/api/Types#types","content":" ","version":null,"tagName":"h2"},{"title":"MigrationStep​","type":1,"pageTitle":"Types","url":"/api/Types#MigrationStep","content":"&lt;/&gt; interface MigrationStep { name: string-- The name of the migration step apply: (data: {[string]: any}) → {[string]: any}-- The function to apply the migration step } A migration step  ","version":null,"tagName":"h3"},{"title":"Level​","type":1,"pageTitle":"Types","url":"/api/Types#Level","content":"enum &lt;/&gt; interface Level { fatal: &quot;fatal&quot; error: &quot;error&quot; warn: &quot;warn&quot; info: &quot;info&quot; debug: &quot;debug&quot; trace: &quot;trace&quot; } An enum value representing a log level.  ","version":null,"tagName":"h3"},{"title":"LogMessage​","type":1,"pageTitle":"Types","url":"/api/Types#LogMessage","content":"&lt;/&gt; interface LogMessage { message: string level: Level context: {[string]: any}? } Represents a log message. ","version":null,"tagName":"h3"},{"title":"Network Updates","type":0,"sectionRef":"#","url":"/docs/advanced/networking","content":"","keywords":"","version":"Next"},{"title":"Understanding Change Callbacks​","type":1,"pageTitle":"Network Updates","url":"/docs/advanced/networking#understanding-change-callbacks","content":" Change callbacks are functions that run whenever data changes, whether through updates or transactions. They receive three parameters:  The key (player UserId as a string)The new data (frozen to prevent mutations)The previous data (if any, also frozen)  Here's a basic example:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Network = require(ReplicatedStorage.Network) local function syncWithClient(key: string, newData, oldData) local player = Players:GetPlayerByUserId(tonumber(key)) if not player then return end -- Send only changed data local changes = {} if newData.coins ~= oldData.coins then changes.coins = newData.coins end if not Tables.deepEquals(newData.inventory, oldData.inventory) then changes.inventory = newData.inventory end -- Send changes to client Network.PlayerData:FireClient(player, changes) end local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, changedCallbacks = { syncWithClient }, })   tip Compare old and new data to send only changed values, reducing network traffic.  ","version":"Next","tagName":"h2"},{"title":"Multiple Callbacks​","type":1,"pageTitle":"Network Updates","url":"/docs/advanced/networking#multiple-callbacks","content":" While changedCallbacks are primarily used for networking, you can register multiple callbacks if needed. Each callback receives the same read-only data:  local store = Lyra.createPlayerStore({ changedCallbacks = { -- Keep clients in sync syncWithClient, -- Log changes for debugging function(key, newData, oldData) print(`Player {key} data changed`) end, }, })   ","version":"Next","tagName":"h2"},{"title":"Data Safety​","type":1,"pageTitle":"Network Updates","url":"/docs/advanced/networking#data-safety","content":" Change callbacks receive frozen copies of the data. This means the data is read-only and cannot be modified:  local function callback(key, newData, oldData) -- ❌ This will error - data is frozen newData.coins = 100 end   ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Network Updates","url":"/docs/advanced/networking#see-also","content":" Core Concepts for understanding data managementGetting Started for basic setup ","version":"Next","tagName":"h2"},{"title":"Data Migrations","type":0,"sectionRef":"#","url":"/docs/advanced/migrations","content":"","keywords":"","version":"Next"},{"title":"How Migrations Work​","type":1,"pageTitle":"Data Migrations","url":"/docs/advanced/migrations#how-migrations-work","content":" When a player's data is loaded, Lyra:  Checks which migrations have already run for this playerRuns any new migrations in orderRecords which migrations were appliedValidates the final data against your schema  This means each migration runs exactly once per player, even if they join multiple times or on different servers.  ","version":"Next","tagName":"h2"},{"title":"Basic Migrations​","type":1,"pageTitle":"Data Migrations","url":"/docs/advanced/migrations#basic-migrations","content":" The simplest migration is adding new fields:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, migrationSteps = Lyra.Migration.new() :fields(&quot;add_player_settings&quot;, { settings = { music = true, sfx = true, } }) :finalize(), })   Migration Names Are Permanent Migration names (like &quot;add_player_settings&quot;) are permanent and help Lyra track which migrations have run. Choose descriptive names that indicate what the migration does, as you can't change them later.  ","version":"Next","tagName":"h2"},{"title":"Transform Steps​","type":1,"pageTitle":"Data Migrations","url":"/docs/advanced/migrations#transform-steps","content":" For more complex changes, use transform steps:  migrationSteps = Lyra.Migration.new() :transform(&quot;inventory_to_items&quot;, function(data) -- Convert simple inventory list to detailed items data.items = {} for item in data.inventory do table.insert(data.items, { id = item, acquired = os.time(), }) end data.inventory = nil return data end) :finalize()   ","version":"Next","tagName":"h2"},{"title":"Multiple Steps​","type":1,"pageTitle":"Data Migrations","url":"/docs/advanced/migrations#multiple-steps","content":" You can chain multiple migration steps:  migrationSteps = Lyra.Migration.new() -- Add new currency :fields(&quot;add_gems&quot;, { gems = 0, }) -- Restructure inventory :transform(&quot;inventory_v2&quot;, function(data) data.inventory = { items = data.inventory, maxSlots = 20, } return data end) :finalize()   Migration Order Is Critical Migrations always run in the order they're defined. This order becomes permanent once published - you can't change it later. If a new migration needs data from an older one, add it after the existing migrations.  ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Data Migrations","url":"/docs/advanced/migrations#best-practices","content":" When working with migrations:  Plan carefully - Once published, migrations can't be changedKeep migrations simple - One logical change per stepTest thoroughly - Migrations run once and can't be undone  ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Data Migrations","url":"/docs/advanced/migrations#see-also","content":" Getting Started for basic Lyra usageDebugging for troubleshooting migrationsCore Concepts for understanding how Lyra works ","version":"Next","tagName":"h2"},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/docs/core-concepts","content":"","keywords":"","version":"Next"},{"title":"Understanding Sessions​","type":1,"pageTitle":"Core Concepts","url":"/docs/core-concepts#understanding-sessions","content":" When a player joins your game, you need a way to work with their data. A session is Lyra's way of managing this connection between your game and a player's saved data.  Sessions utilize 'session locking' to keep data safe. When you load a player's data, Lyra 'locks' it, which gives your server exclusive access to that data. This is crucial - without session locking, multiple servers might try to modify the same player's data simultaneously, leading to race conditions and lost data.  Here's how you work with sessions:  Players.PlayerAdded:Connect(function(player) -- Establish exclusive access to the player's data store:load(player):expect() end) Players.PlayerRemoving:Connect(function(player) -- Release the lock and save any pending changes store:unload(player) end)   Loading a session is always your first step. Any attempts to access or modify data before establishing a session will fail, as Lyra needs to ensure exclusive access before allowing operations.  ","version":"Next","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Core Concepts","url":"/docs/core-concepts#working-with-data","content":" Once you have a session, you can start working with the player's data. Lyra provides a structured way to make changes through updates.  An update is a function that receives the current data and can modify it mutably. The function must return true to commit the changes, providing an atomic way to perform conditional updates:  store:update(player, function(data) if data.coins &lt; itemPrice then return false -- Abort the update end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end)   This pattern enables you to encapsulate your game's logic within updates while ensuring data consistency. The update either succeeds completely or fails entirely - there's no possibility of partial changes.  Don't Yield! Lyra enforces that updates are synchronous and non-blocking - if you yield inside the update function, it will error and abort the operation.  ","version":"Next","tagName":"h2"},{"title":"Handling Multiple Players​","type":1,"pageTitle":"Core Concepts","url":"/docs/core-concepts#handling-multiple-players","content":" Sometimes you need to coordinate changes across multiple players, like in a trading system.  If you update each player individually, there's no guarantee that one player's changes will succeed while the other's fail - imagine a server crashing at exactly the right moment.  This is where transactions come in.  A transaction lets you modify multiple players' data atomically. Either all the changes succeed, or none of them do. This is crucial for maintaining data consistency:  store:tx({player1, player2}, function(state) local item = table.remove(state[player1].inventory, 1) if not item then return false -- Abort the transaction end table.insert(state[player2].inventory, item) return true end)   The transaction ensures the atomicity of multi-player operations. You'll never end up in a state where an item has been removed from one player but not added to another, which is essential for maintaining the integrity of your game's economy.  ","version":"Next","tagName":"h2"},{"title":"Data Validation​","type":1,"pageTitle":"Core Concepts","url":"/docs/core-concepts#data-validation","content":" Data validation in Lyra works through schemas. When you create a store, you define what valid data looks like:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = { coins = 0, inventory = {}, }, schema = t.strictInterface({ coins = t.number, inventory = t.table, }), })   Lyra enforces this schema on every operation, creating a safe boundary between your game logic and DataStores. If an operation would result in invalid data, Lyra rejects it before it can be saved.  tip We recommend using 't', a Runtime Typechecker for Roblox for defining schemas!  ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Core Concepts","url":"/docs/core-concepts#next-steps","content":" Now that you understand the core concepts, you might want to:  Learn about migrations for updating your data formatExplore debugging for troubleshootingSee how to handle network updates ","version":"Next","tagName":"h2"},{"title":"Debugging","type":0,"sectionRef":"#","url":"/docs/advanced/debugging","content":"","keywords":"","version":"Next"},{"title":"Understanding Logs​","type":1,"pageTitle":"Debugging","url":"/docs/advanced/debugging#understanding-logs","content":" Each log message contains:  A severity levelA descriptive messageOptional context with additional details  Here's a basic setup that prints all logs:  local function handleLogs(message) print(`[Lyra][{string.upper(message.level)}] {message.message}`) if message.context then -- Context contains relevant data like keys, session info, etc. print(&quot;Context:&quot;, message.context) end end local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, logCallback = handleLogs, })   ","version":"Next","tagName":"h2"},{"title":"Log Levels​","type":1,"pageTitle":"Debugging","url":"/docs/advanced/debugging#log-levels","content":" Lyra uses different levels to categorize logs:  local function handleLogs(message) -- Handle based on severity if message.level == &quot;fatal&quot; then -- Unrecoverable errors (e.g., corrupted data) warn(&quot;FATAL:&quot;, message.message) elseif message.level == &quot;error&quot; then -- Operation failures (e.g., update failed) warn(&quot;Error:&quot;, message.message) elseif message.level == &quot;warn&quot; then -- Potential issues (e.g., slow operations) warn(&quot;Warning:&quot;, message.message) elseif message.level == &quot;info&quot; then -- Important operations (e.g., session started) print(&quot;Info:&quot;, message.message) elseif message.level == &quot;debug&quot; then -- Detailed operation info print(&quot;Debug:&quot;, message.message) elseif message.level == &quot;trace&quot; then -- Very detailed debugging info print(&quot;Trace:&quot;, message.message) end end   ","version":"Next","tagName":"h2"},{"title":"Development Mode​","type":1,"pageTitle":"Debugging","url":"/docs/advanced/debugging#development-mode","content":" You often want more detailed logs in Studio:  local RunService = game:GetService(&quot;RunService&quot;) local function createLogger() if RunService:IsStudio() then -- Show all logs in Studio return function(message) print(`[Lyra][{message.level}] {message.message}`) if message.context then print(&quot;Context:&quot;, message.context) end end else -- Only show errors in production return function(message) if message.level == &quot;error&quot; or message.level == &quot;fatal&quot; then warn(`[Lyra] {message.message}`) end end end end local store = Lyra.createPlayerStore({ logCallback = createLogger(), })   tip The context object often contains useful debugging information like session IDs, keys being operated on, and timing data.  ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Debugging","url":"/docs/advanced/debugging#see-also","content":" Core Concepts for understanding operationsGetting Started for basic setup ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"/docs/intro#features","content":" Data Safety  🔒 Session Locking - Prevents multiple servers from corrupting each other's data⚔️ Transactions - Safe trading between players - no more item duplication bugs👁️ Validation - Catches bad data before it gets saved  Performance  💎 Auto-Sharding - Handles large data by automatically splitting across multiple keys⚡ Efficient - Minimizes DataStore calls and bandwidth usage🎯 Auto-Retry - Handles DataStore errors and throttling automatically  Development  🦋 Migrations - Update your data format without breaking existing saves🔄 Drop-in - Import your existing data and switch over seamlessly  ","version":"Next","tagName":"h2"},{"title":"Quick Example​","type":1,"pageTitle":"Introduction","url":"/docs/intro#quick-example","content":" Here's what using Lyra looks like:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = { coins = 0, inventory = {}, }, schema = t.strictInterface({ coins = t.number, inventory = t.table, }), }) -- Load data when players join Players.PlayerAdded:Connect(function(player) store:load(player):expect() end) -- Safe updates with validation store:update(player, function(data) if data.coins &lt; itemPrice then return false -- Abort if can't afford end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end):expect() -- Atomic trades between players store:tx({player1, player2}, function(state) -- Either both changes happen or neither does state[player1].coins -= 100 state[player2].coins += 100 return true end):expect()   Avoid Stale Data Always modify data through update functions. Never use data from a previous :get() call: -- 🚫 Don't do this: local oldData = store:get(player):expect() store:update(player, function(newData) if not oldData.claimedDailyReward then -- This data might be stale! return false end newData.coins += 500 newData.claimedDailyReward = true return true end) -- ✅ Do this instead: store:update(player, function(data) if not data.claimedDailyReward then -- This data is always current return false end data.coins += 500 data.claimedDailyReward = true return true end)   ","version":"Next","tagName":"h2"},{"title":"Importing Existing Data​","type":1,"pageTitle":"Introduction","url":"/docs/intro#importing-existing-data","content":" When switching to Lyra, you can bring your existing data:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, importLegacyData = function(key) local success, data = pcall(function() return YourCurrentSystem.getData(key) end) if not success then -- If there's an error, Lyra will kick the player and prompt them -- to rejoin to try again. error(&quot;Failed to reach data system&quot;) end if data ~= nil then return data -- Return existing data to import end return nil -- Return nil for new players to use template end, })   ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/docs/intro#installation","content":" Add to your wally.toml:  [dependencies] Lyra = &quot;paradoxum-games/lyra@0.1.0&quot;   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/docs/intro#next-steps","content":" Check out Getting Started for a complete setup guideRead Core Concepts to understand how Lyra worksSee the Advanced Features section for migration guides and debugging tips ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/getting-started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#installation","content":" Add Lyra to your wally.toml:  [dependencies] Lyra = &quot;paradoxum-games/lyra@0.1.0&quot;   tip If you're new to Wally, check out the Wally installation guide.  ","version":"Next","tagName":"h2"},{"title":"Basic Setup​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#basic-setup","content":" Here's how to set up Lyra with a simple data structure:  local Players = game:GetService(&quot;Players&quot;) local Lyra = require(path.to.Lyra) -- Define your data template local template = { coins = 0, inventory = {}, } -- Create schema to validate data local schema = t.strictInterface({ coins = t.number, inventory = t.table, }) -- Create the store local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, }) -- Load data when players join Players.PlayerAdded:Connect(function(player) store:load(player):expect() end) -- Save and clean up when they leave Players.PlayerRemoving:Connect(function(player) store:unload(player):expect() end)   ","version":"Next","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#working-with-data","content":" ","version":"Next","tagName":"h2"},{"title":"Reading Data​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#reading-data","content":" You can read player data, but remember that it might change between reads:  store:get(player):andThen(function(data) -- ⚠️ Only use this data for reading -- Don't save it for later use print(`{player.Name} has {data.coins} coins`) end)   ","version":"Next","tagName":"h3"},{"title":"Modifying Data​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#modifying-data","content":" Always modify data through update functions:  -- Simple update store:update(player, function(data) data.coins += 100 return true end) -- Conditional update store:update(player, function(data) if data.coins &lt; itemPrice then return false -- Abort the update end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end)   ","version":"Next","tagName":"h3"},{"title":"Trading Between Players​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#trading-between-players","content":" Use transactions for operations involving multiple players:  store:tx({player1, player2}, function(state) -- Transfer coins if state[player1].coins &lt; amount then return false -- Abort if not enough coins end state[player1].coins -= amount state[player2].coins += amount return true end)   ","version":"Next","tagName":"h3"},{"title":"Error Handling​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#error-handling","content":" Lyra operations return promises that you can handle in different ways:  -- Using :expect(), which will throw an error if the operation fails store:update(player, function(data) data.coins -= itemPrice data.inventory.weapon = &quot;starter_sword&quot; return true end):expect() -- Using :andThen() and :catch() store:update(player, function(data) data.coins -= itemPrice data.inventory.weapon = &quot;starter_sword&quot; return true end):andThen(function() print(&quot;Purchase successful!&quot;) end):catch(function(err) print(`Purchase failed: {err}`) end)   ","version":"Next","tagName":"h2"},{"title":"Importing Existing Data​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#importing-existing-data","content":" If you're migrating from another system, you can import your existing data:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, importLegacyData = function(key) local success, data = pcall(function() return YourCurrentSystem.getData(key) end) if not success then error(&quot;Failed to reach data system&quot;) -- Player will be kicked and can retry end if data ~= nil then return data -- Return existing data to import end return nil -- Return nil for new players to use template end, })   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started#next-steps","content":" Now that you've got the basics down, check out:  Core Concepts for a deeper understandingData Migrations for updating data structureNetwork Updates for client synchronizationDebugging for troubleshooting ","version":"Next","tagName":"h2"},{"title":"Store","type":0,"sectionRef":"#","url":"/api/Store","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Store","url":"/api/Store#types","content":" ","version":null,"tagName":"h2"},{"title":"StoreConfig​","type":1,"pageTitle":"Store","url":"/api/Store#StoreConfig","content":"&lt;/&gt; interface StoreConfig { name: string-- Name of the store template: T-- Template/default value for new data schema: (value: any) → ( boolean, string? )-- Validates data format migrationSteps?: {MigrationStep}-- Steps to migrate old data formats importLegacyData?: (key: string) → any?-- Function to import legacy data dataStoreInterface?: DataStoreInterface-- Custom DataStore implementation useMock?: boolean-- Use mock DataStore (Studio only) changedCallbacks?: {( key: string, newData: T, oldData: T? ) → () → ()}-- Run when data changes logCallback?: (logMessage: LogMessage) → ()-- Custom logging function onLockLost?: (key: string) → ()-- Called if DataStore lock is lost } Configuration for creating a new Store. Example usage: local config: StoreConfig&lt;PlayerData&gt; = { name = &quot;PlayerData&quot;, template = { coins = 0, items = {}, }, schema = function(value) return type(value.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/api/Store#functions","content":" ","version":null,"tagName":"h2"},{"title":"createStore​","type":1,"pageTitle":"Store","url":"/api/Store#createStore","content":"&lt;/&gt; Store.createStore( config: StoreConfig&lt;T&gt;-- Configuration for the store ) → Store&lt;T&gt; Creates a new Store with the given configuration. local store = Store.createStore({ name = &quot;PlayerData&quot;, template = { coins = 0 }, schema = function(data) return type(data.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, -- Optional: Runs whenever data changes changedCallbacks = { function(key, newData, oldData) print(key, &quot;changed from&quot;, oldData.coins, &quot;to&quot;, newData.coins) end, }, -- Optional: Called if lock is lost during session onLockLost = function(key) warn(&quot;Lost lock for&quot;, key) end, }) CAUTION If schema validation fails at any point, operations will be rejected with the error message.  ","version":null,"tagName":"h3"},{"title":"load​","type":1,"pageTitle":"Store","url":"/api/Store#load","content":"&lt;/&gt; Store:load( key: string, userIds: {number}? ) → Promise-- Resolves when data is loaded Loads data for the given key into memory and establishes a session. Must be called before using any other methods with this key. store:load(&quot;player_1&quot;):andThen(function() print(&quot;Data loaded!&quot;) end):catch(function(err) warn(&quot;Failed to load:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/api/Store##","content":"Type\tDescription&quot;Load already in progress&quot;\tAnother load is already in progress for this key &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"Store","url":"/api/Store#unload","content":"&lt;/&gt; Store:unload(key: string) → Promise-- Resolves when data is unloaded Unloads data for the given key from memory and ends the session. store:unload(&quot;player_1&quot;):andThen(function() print(&quot;Data unloaded!&quot;) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/api/Store##","content":"Type\tDescription&quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"Store","url":"/api/Store#get","content":"&lt;/&gt; Store:get(key: string) → Promise&lt;T&gt;-- Resolves with the current data Gets the current data for the given key. store:get(&quot;player_1&quot;):andThen(function(data) print(&quot;Current coins:&quot;, data.coins) end):catch(function(err) warn(&quot;Failed to get data:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe key hasn't been loaded with store:load() &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Store","url":"/api/Store#update","content":"&lt;/&gt; Store:update( key: string, transformFunction: (data: T) → boolean ) → Promise-- Resolves when the update is complete Updates data for the given key using a transform function. The transform function receives the current data and can modify it. Must return true to commit changes, or false to abort. store:update(&quot;player_1&quot;, function(data) if data.coins &lt; 100 then data.coins += 50 return true -- Commit changes end return false -- Don't commit changes end):andThen(function() print(&quot;Update successful!&quot;) end):catch(function(err) warn(&quot;Update failed:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe key hasn't been loaded with store:load() &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"tx​","type":1,"pageTitle":"Store","url":"/api/Store#tx","content":"&lt;/&gt; Store:tx( keys: {string}, transformFunction: (state: {[string]: T}) → boolean ) → Promise-- Resolves when the transaction is complete Performs a transaction across multiple keys atomically. All keys must be loaded first. Either all changes are applied, or none are. store:tx({&quot;player_1&quot;, &quot;player_2&quot;}, function(state) -- Transfer coins between players if state.player_1.coins &gt;= 100 then state.player_1.coins -= 100 state.player_2.coins += 100 return true -- Commit transaction end return false -- Abort transaction end):andThen(function() print(&quot;Transaction successful!&quot;) end):catch(function(err) warn(&quot;Transaction failed:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tOne or more keys haven't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation &quot;Keys changed in transaction&quot;\tThe transform function modified the keys table  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"Store","url":"/api/Store#save","content":"&lt;/&gt; Store:save(key: string) → Promise-- Resolves when the save is complete Forces an immediate save of the given key's data. INFO Data is automatically saved periodically, so manual saves are usually only useful in scenarios where you need to guarantee data has saved, such as ProcessReceipt. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe key hasn't been loaded with store:load() &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"close​","type":1,"pageTitle":"Store","url":"/api/Store#close","content":"&lt;/&gt; Store:close() → Promise-- Resolves when the store is closed Closes the store and unloads all active sessions. The store cannot be used after closing  ","version":null,"tagName":"h3"},{"title":"probeLockActive​","type":1,"pageTitle":"Store","url":"/api/Store#probeLockActive","content":"&lt;/&gt; Store:probeLockActive(key: string) → Promise&lt;boolean&gt; Checks if a lock is currently active for the given key.  ","version":null,"tagName":"h3"},{"title":"listVersions​","type":1,"pageTitle":"Store","url":"/api/Store#listVersions","content":"&lt;/&gt; Store:listVersions(params: ListVersionParams) → Promise&lt;DataStoreVersionPages &gt; Returns DataStoreVersionPages for the given key.  ","version":null,"tagName":"h3"},{"title":"readVersion​","type":1,"pageTitle":"Store","url":"/api/Store#readVersion","content":"&lt;/&gt; Store:readVersion( key: string, version: string ) → Promise&lt;T,DataStoreKeyInfo &gt; Reads a specific version of data for the given key. ","version":null,"tagName":"h3"},{"title":"PlayerStore","type":0,"sectionRef":"#","url":"/api/PlayerStore","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#types","content":" ","version":null,"tagName":"h2"},{"title":"PlayerStoreConfig​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#PlayerStoreConfig","content":"&lt;/&gt; interface PlayerStoreConfig { name: string-- The name of the store template: T-- The template data for new keys schema: (value: any) → ( boolean, string? )-- A function to validate data migrationSteps: {MigrationStep}?-- Optional migration steps importLegacyData: ((key: string) → any?)?-- Optional function to import legacy data changedCallbacks: {( key: string, newData: T, oldData: T? ) → () → ()}?-- Optional callbacks for data changes logCallback: ((logMessage: LogMessage) → ())?-- Optional callback for log messages } Configuration for creating a new Store. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#functions","content":" ","version":null,"tagName":"h2"},{"title":"create​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#create","content":"&lt;/&gt; PlayerStore.create( config: PlayerStoreConfig&lt;T&gt;-- Configuration for the store ) → PlayerStore&lt;T&gt; Creates a new PlayerStore with the given configuration. Configuration is similar to Store.createStore, but automatically adds player kick handling. local playerStore = PlayerStore.create({ name = &quot;PlayerData&quot;, template = { coins = 0 }, schema = function(data) return type(data.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, -- Optional: Runs whenever data changes changedCallbacks = { function(key, newData, oldData) print(key, &quot;changed from&quot;, oldData.coins, &quot;to&quot;, newData.coins) end, }, }) Players will be automatically kicked with an error message if: Their data fails to load The DataStore lock is lost during their session  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#get","content":"&lt;/&gt; PlayerStore:get(player: Player ) → Promise&lt;T&gt;-- Resolves with the player's data Gets the current data for the given player. playerStore:get(player):andThen(function(data) print(player.Name, &quot;has&quot;, data.coins, &quot;coins&quot;) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"load​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#load","content":"&lt;/&gt; PlayerStore:load(player: Player ) → () Loads data for the given player. Must be called before using other methods. playerStore:load(player):andThen(function() print(&quot;Data loaded for&quot;, player.Name) end) CAUTION If loading fails, the player will be kicked from the game. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore##","content":"Type\tDescription&quot;Load already in progress&quot;\tAnother load is in progress for this player &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#unload","content":"&lt;/&gt; PlayerStore:unload(player: Player ) → () Unloads data for the given player. playerStore:unload(player):andThen(function() print(&quot;Data unloaded for&quot;, player.Name) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore##","content":"Type\tDescription&quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#update","content":"&lt;/&gt; PlayerStore:update( player: Player , transformFunction: (data: T) → boolean ) → () Updates data for the given player using a transform function. The transform function must return true to commit changes, or false to abort. playerStore:update(player, function(data) if data.coins &lt; 100 then data.coins += 50 return true -- Commit changes end return false -- Don't commit changes end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"tx​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#tx","content":"&lt;/&gt; PlayerStore:tx( players: {Player }, transformFunction: (state: {[Player ]: T}) → boolean ) → () Performs a transaction across multiple players' data atomically. All players' data must be loaded first. Either all changes apply or none do. playerStore:tx({player1, player2}, function(state) -- Transfer coins between players if state[player1].coins &gt;= 100 then state[player1].coins -= 100 state[player2].coins += 100 return true -- Commit transaction end return false -- Abort transaction end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tOne or more players' data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#save","content":"&lt;/&gt; PlayerStore:save(player: Player ) → () Forces an immediate save of the given player's data. INFO Data is automatically saved periodically, so manual saves are usually unnecessary. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"close​","type":1,"pageTitle":"PlayerStore","url":"/api/PlayerStore#close","content":"&lt;/&gt; PlayerStore:close() → () Closes the store and unloads all active sessions. The store cannot be used after closing. ","version":null,"tagName":"h3"}],"options":{"id":"default"}}