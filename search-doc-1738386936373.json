{"searchDocs":[{"title":"PlayerStore","type":0,"sectionRef":"#","url":"/lyra/api/PlayerStore","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#types","content":" ","version":null,"tagName":"h2"},{"title":"PlayerStoreConfig​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#PlayerStoreConfig","content":"&lt;/&gt; interface PlayerStoreConfig { name: string-- The name of the store template: T-- The template data for new keys schema: (value: any) → ( boolean, string? )-- A function to validate data migrationSteps: {MigrationStep}?-- Optional migration steps importLegacyData: ((key: string) → any?)?-- Optional function to import legacy data changedCallbacks: {( key: string, newData: T, oldData: T? ) → () → ()}?-- Optional callbacks for data changes logCallback: ((logMessage: LogMessage) → ())?-- Optional callback for log messages memoryStoreService: MemoryStoreService? -- Optional MemoryStoreService instance for mocking dataStoreService: DataStoreService? -- Optional DataStoreService instance for mocking } Configuration for creating a new Store. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#functions","content":" ","version":null,"tagName":"h2"},{"title":"create​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#create","content":"&lt;/&gt; PlayerStore.create( config: PlayerStoreConfig&lt;T&gt;-- Configuration for the store ) → PlayerStore&lt;T&gt; Creates a new PlayerStore with the given configuration. Configuration is similar to Store.createStore, but automatically adds player kick handling. local playerStore = PlayerStore.create({ name = &quot;PlayerData&quot;, template = { coins = 0 }, schema = function(data) return typeof(data.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, -- Optional: Runs whenever data changes changedCallbacks = { function(key, newData, oldData) print(key, &quot;changed from&quot;, oldData.coins, &quot;to&quot;, newData.coins) end, }, }) Players will be automatically kicked with an error message if: Their data fails to load The DataStore lock is lost during their session  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#get","content":"&lt;/&gt; PlayerStore:get(player: Player ) → Promise&lt;T&gt;-- Resolves with the player's data Gets the current data for the given player. playerStore:get(player):andThen(function(data) print(player.Name, &quot;has&quot;, data.coins, &quot;coins&quot;) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"getAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#getAsync","content":"&lt;/&gt; PlayerStore:getAsync(player: Player ) → () Syntactic sugar for playerStore:get(player):expect(). See PlayerStore:get  ","version":null,"tagName":"h3"},{"title":"load​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#load","content":"&lt;/&gt; PlayerStore:load(player: Player ) → Promise-- Resolves when data is loaded Loads data for the given player. Must be called before using other methods. playerStore:load(player):andThen(function() print(&quot;Data loaded for&quot;, player.Name) end) CAUTION If loading fails, the player will be kicked from the game. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Load already in progress&quot;\tAnother load is in progress for this player &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"loadAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#loadAsync","content":"&lt;/&gt; PlayerStore:loadAsync(player: Player ) → () Syntactic sugar for playerStore:load(player):expect(). See PlayerStore:load  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#unload","content":"&lt;/&gt; PlayerStore:unload(player: Player ) → Promise&lt;boolean&gt;-- Resolves when the update is complete, with a boolean indicating success Unloads data for the given player. playerStore:unload(player):andThen(function() print(&quot;Data unloaded for&quot;, player.Name) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"unloadAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#unloadAsync","content":"&lt;/&gt; PlayerStore:unloadAsync(player: Player ) → () Syntactic sugar for playerStore:unload(player):expect(). See PlayerStore:unload  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#update","content":"&lt;/&gt; PlayerStore:update( player: Player , transformFunction: (data: T) → boolean ) → Promise-- Resolves when the update is complete Updates data for the given player using a transform function. The transform function must return true to commit changes, or false to abort. playerStore:update(player, function(data) if data.coins &lt; 100 then data.coins += 50 return true -- Commit changes end return false -- Don't commit changes end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"updateAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#updateAsync","content":"&lt;/&gt; PlayerStore:updateAsync( player: Player , transformFunction: (data: T) → boolean ) → () Syntactic sugar for playerStore:update(player, transformFunction):expect(). See PlayerStore:update  ","version":null,"tagName":"h3"},{"title":"tx​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#tx","content":"&lt;/&gt; PlayerStore:tx( players: {Player }, transformFunction: (state: {[Player ]: T}) → boolean ) → Promise-- Resolves when the transaction is complete Performs a transaction across multiple players' data atomically. All players' data must be loaded first. Either all changes apply or none do. playerStore:tx({player1, player2}, function(state) -- Transfer coins between players if state[player1].coins &gt;= 100 then state[player1].coins -= 100 state[player2].coins += 100 return true -- Commit transaction end return false -- Abort transaction end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tOne or more players' data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"txAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#txAsync","content":"&lt;/&gt; PlayerStore:txAsync( players: {Player }, transformFunction: (state: {[Player ]: T}) → boolean ) → () Syntactic sugar for playerStore:tx(players, transformFunction):expect(). See PlayerStore:tx  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#save","content":"&lt;/&gt; PlayerStore:save(player: Player ) → Promise-- Resolves when the save is complete Forces an immediate save of the given player's data. INFO Data is automatically saved periodically, so manual saves are usually unnecessary. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe player's data hasn't been loaded &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"saveAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#saveAsync","content":"&lt;/&gt; PlayerStore:saveAsync(player: Player ) → () Syntactic sugar for playerStore:save(player):expect(). See PlayerStore:save  ","version":null,"tagName":"h3"},{"title":"close​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#close","content":"&lt;/&gt; PlayerStore:close() → Promise-- Resolves when the store is closed Closes the store and unloads all active sessions. The store cannot be used after closing.  ","version":null,"tagName":"h3"},{"title":"closeAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#closeAsync","content":"&lt;/&gt; PlayerStore:closeAsync() → () Syntactic sugar for playerStore:close():expect(). See PlayerStore:close  ","version":null,"tagName":"h3"},{"title":"peek​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#peek","content":"&lt;/&gt; PlayerStore:peek(userId: number) → Promise&lt;T&gt;-- Resolves with the current data Returns the current data for the given key without loading it into the store. playerStore:peek(userId):andThen(function(data) print(&quot;Current coins:&quot;, data.coins) end)   ","version":null,"tagName":"h3"},{"title":"peekAsync​","type":1,"pageTitle":"PlayerStore","url":"/lyra/api/PlayerStore#peekAsync","content":"&lt;/&gt; PlayerStore:peekAsync(userId: number) → () Syntactic sugar for playerStore:peek(userId):expect(). See PlayerStore:peek ","version":null,"tagName":"h3"},{"title":"Store","type":0,"sectionRef":"#","url":"/lyra/api/Store","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#types","content":" ","version":null,"tagName":"h2"},{"title":"StoreConfig​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#StoreConfig","content":"&lt;/&gt; interface StoreConfig { name: string-- Name of the store template: T-- Template/default value for new data schema: (value: any) → ( boolean, string? )-- Validates data format migrationSteps?: {MigrationStep}-- Steps to migrate old data formats importLegacyData?: (key: string) → any?-- Function to import legacy data dataStoreService?: DataStoreService -- Custom DataStore implementation useMock?: boolean-- Use mock DataStore (Studio only) changedCallbacks?: {( key: string, newData: T, oldData: T? ) → () → ()}-- Run when data changes logCallback?: (logMessage: LogMessage) → ()-- Custom logging function onLockLost?: (key: string) → ()-- Called if DataStore lock is lost } Configuration for creating a new Store. Example usage: local config: StoreConfig&lt;PlayerData&gt; = { name = &quot;PlayerData&quot;, template = { coins = 0, items = {}, }, schema = function(value) return typeof(value.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#functions","content":" ","version":null,"tagName":"h2"},{"title":"createStore​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#createStore","content":"&lt;/&gt; Store.createStore( config: StoreConfig&lt;T&gt;-- Configuration for the store ) → Store&lt;T&gt; Creates a new Store with the given configuration. local store = Store.createStore({ name = &quot;PlayerData&quot;, template = { coins = 0 }, schema = function(data) return typeof(data.coins) == &quot;number&quot;, &quot;coins must be a number&quot; end, -- Optional: Runs whenever data changes changedCallbacks = { function(key, newData, oldData) print(key, &quot;changed from&quot;, oldData.coins, &quot;to&quot;, newData.coins) end, }, -- Optional: Called if lock is lost during session onLockLost = function(key) warn(&quot;Lost lock for&quot;, key) end, }) CAUTION If schema validation fails at any point, operations will be rejected with the error message.  ","version":null,"tagName":"h3"},{"title":"load​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#load","content":"&lt;/&gt; Store:load( key: string, userIds: {number}? ) → Promise-- Resolves when data is loaded Loads data for the given key into memory and establishes a session. Must be called before using any other methods with this key. store:load(&quot;player_1&quot;):andThen(function() print(&quot;Data loaded!&quot;) end):catch(function(err) warn(&quot;Failed to load:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Load already in progress&quot;\tAnother load is already in progress for this key &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"loadAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#loadAsync","content":"&lt;/&gt; Store:loadAsync( key: string, userIds: {number}? ) → () Syntactic sugar for store:load(key):expect(). See Store:load  ","version":null,"tagName":"h3"},{"title":"unload​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#unload","content":"&lt;/&gt; Store:unload(key: string) → Promise-- Resolves when data is unloaded Unloads data for the given key from memory and ends the session. store:unload(&quot;player_1&quot;):andThen(function() print(&quot;Data unloaded!&quot;) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"unloadAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#unloadAsync","content":"&lt;/&gt; Store:unloadAsync(key: string) → () Syntactic sugar for store:unload(key):expect(). See Store:unload  ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#get","content":"&lt;/&gt; Store:get(key: string) → Promise&lt;T&gt;-- Resolves with the current data Gets the current data for the given key. store:get(&quot;player_1&quot;):andThen(function(data) print(&quot;Current coins:&quot;, data.coins) end):catch(function(err) warn(&quot;Failed to get data:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe key hasn't been loaded with store:load() &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"getAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#getAsync","content":"&lt;/&gt; Store:getAsync(key: string) → T Syntactic sugar for store:get(key):expect(). See Store:get  ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#update","content":"&lt;/&gt; Store:update( key: string, transformFunction: (data: T) → boolean ) → Promise&lt;boolean&gt;-- Resolves when the update is complete, with a boolean indicating success Updates data for the given key using a transform function. The transform function receives the current data and can modify it. Must return true to commit changes, or false to abort. store:update(&quot;player_1&quot;, function(data) if data.coins &lt; 100 then data.coins += 50 return true -- Commit changes end return false -- Don't commit changes end):andThen(function() print(&quot;Update successful!&quot;) end):catch(function(err) warn(&quot;Update failed:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe key hasn't been loaded with store:load() &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation  ","version":null,"tagName":"h3"},{"title":"updateAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#updateAsync","content":"&lt;/&gt; Store:updateAsync( key: string, transformFunction: (data: T) → boolean ) → boolean Syntactic sugar for store:update(key, transformFunction):expect(). See Store:update  ","version":null,"tagName":"h3"},{"title":"tx​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#tx","content":"&lt;/&gt; Store:tx( keys: {string}, transformFunction: (state: {[string]: T}) → boolean ) → Promise-- Resolves when the transaction is complete Performs a transaction across multiple keys atomically. All keys must be loaded first. Either all changes are applied, or none are. store:tx({&quot;player_1&quot;, &quot;player_2&quot;}, function(state) -- Transfer coins between players if state.player_1.coins &gt;= 100 then state.player_1.coins -= 100 state.player_2.coins += 100 return true -- Commit transaction end return false -- Abort transaction end):andThen(function() print(&quot;Transaction successful!&quot;) end):catch(function(err) warn(&quot;Transaction failed:&quot;, err) end)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tOne or more keys haven't been loaded &quot;Store is closed&quot;\tThe store has been closed &quot;Schema validation failed&quot;\tThe transformed data failed schema validation &quot;Keys changed in transaction&quot;\tThe transform function modified the keys table  ","version":null,"tagName":"h3"},{"title":"txAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#txAsync","content":"&lt;/&gt; Store:txAsync( keys: {string}, transformFunction: (state: {[string]: T}) → boolean ) → () Syntactic sugar for store:tx(keys, transformFunction):expect(). See Store:tx  ","version":null,"tagName":"h3"},{"title":"save​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#save","content":"&lt;/&gt; Store:save(key: string) → Promise-- Resolves when the save is complete Forces an immediate save of the given key's data. INFO Data is automatically saved periodically, so manual saves are usually only useful in scenarios where you need to guarantee data has saved, such as ProcessReceipt. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Store","url":"/lyra/api/Store##","content":"Type\tDescription&quot;Key not loaded&quot;\tThe key hasn't been loaded with store:load() &quot;Store is closed&quot;\tThe store has been closed  ","version":null,"tagName":"h3"},{"title":"saveAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#saveAsync","content":"&lt;/&gt; Store:saveAsync(key: string) → () Syntactic sugar for store:save(key):expect(). See Store:save  ","version":null,"tagName":"h3"},{"title":"close​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#close","content":"&lt;/&gt; Store:close() → Promise-- Resolves when the store is closed Closes the store and unloads all active sessions. The store cannot be used after closing  ","version":null,"tagName":"h3"},{"title":"closeAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#closeAsync","content":"&lt;/&gt; Store:closeAsync() → () Syntactic sugar for store:close():expect(). See Store:close  ","version":null,"tagName":"h3"},{"title":"peek​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#peek","content":"&lt;/&gt; Store:peek(key: string) → Promise&lt;T&gt;-- Resolves with the current data Returns the current data for the given key without loading it into the store. store:peek(&quot;456123&quot;):andThen(function(data) print(&quot;Current coins:&quot;, data.coins) end):catch(function(err) warn(&quot;Failed to peek data:&quot;, err) end)   ","version":null,"tagName":"h3"},{"title":"peekAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#peekAsync","content":"&lt;/&gt; Store:peekAsync(key: string) → T Syntactic sugar for store:peek(key):expect(). See Store:peek  ","version":null,"tagName":"h3"},{"title":"probeLockActive​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#probeLockActive","content":"&lt;/&gt; Store:probeLockActive(key: string) → Promise&lt;boolean&gt; Checks if a lock is currently active for the given key.  ","version":null,"tagName":"h3"},{"title":"probeLockActiveAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#probeLockActiveAsync","content":"&lt;/&gt; Store:probeLockActiveAsync(key: string) → boolean Syntactic sugar for store:probeLockActive(key):expect(). See Store:probeLockActive  ","version":null,"tagName":"h3"},{"title":"listVersions​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#listVersions","content":"&lt;/&gt; Store:listVersions(params: ListVersionParams) → Promise&lt;DataStoreVersionPages &gt; Returns DataStoreVersionPages for the given key.  ","version":null,"tagName":"h3"},{"title":"listVersionsAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#listVersionsAsync","content":"&lt;/&gt; Store:listVersionsAsync(params: ListVersionParams) → DataStoreVersionPages  Syntactic sugar for store:listVersions(params):expect(). See Store:listVersions  ","version":null,"tagName":"h3"},{"title":"readVersion​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#readVersion","content":"&lt;/&gt; Store:readVersion( key: string, version: string ) → Promise&lt;T,DataStoreKeyInfo &gt; Reads a specific version of data for the given key.  ","version":null,"tagName":"h3"},{"title":"readVersionAsync​","type":1,"pageTitle":"Store","url":"/lyra/api/Store#readVersionAsync","content":"&lt;/&gt; Store:readVersionAsync( key: string, version: string ) → ( T, DataStoreKeyInfo ) Syntactic sugar for store:readVersion(key, version):expect(). See Store:readVersion ","version":null,"tagName":"h3"},{"title":"Types","type":0,"sectionRef":"#","url":"/lyra/api/Types","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#types","content":" ","version":null,"tagName":"h2"},{"title":"MigrationStep​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#MigrationStep","content":"&lt;/&gt; interface MigrationStep { name: string-- The name of the migration step apply: (data: {[string]: any}) → {[string]: any}-- The function to apply the migration step } A migration step  ","version":null,"tagName":"h3"},{"title":"LogLevel​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#LogLevel","content":"enum &lt;/&gt; interface LogLevel { fatal: &quot;fatal&quot; error: &quot;error&quot; warn: &quot;warn&quot; info: &quot;info&quot; debug: &quot;debug&quot; trace: &quot;trace&quot; } An enum value representing a log level.  ","version":null,"tagName":"h3"},{"title":"LogMessage​","type":1,"pageTitle":"Types","url":"/lyra/api/Types#LogMessage","content":"&lt;/&gt; interface LogMessage { message: string level: LogLevel context: {[string]: any}? } Represents a log message. ","version":null,"tagName":"h3"},{"title":"Data Migrations","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/migrations","content":"","keywords":"","version":"Next"},{"title":"How Migrations Work​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#how-migrations-work","content":" When a player's data is loaded, Lyra:  Checks which migrations have already run for this playerRuns any new migrations in orderRecords which migrations were appliedValidates the final data against your schema  This means each migration runs exactly once per player, even if they join multiple times or on different servers.  Migration Order Migrations always run in the order they're defined. Once published, this order is permanent and should never be changed. In the snippet below, addLevel will always run after addSettings.  ","version":"Next","tagName":"h2"},{"title":"Adding New Fields​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#adding-new-fields","content":" When adding new fields to your data, follow these steps:  Add the field to your template with its default valueAdd the field to your schema to define its type/validationCreate a migration step using addFields to add it to existing data  For example:  -- Step 1: Add to template local template = { coins = 0, -- Existing field gems = 0, -- New field } -- Step 2: Add to schema local schema = { coins = t.number, gems = t.number, -- New field } -- Step 3: Add migration local store = Lyra.createPlayerStore({ template = template, schema = schema, migrationSteps = { Lyra.MigrationStep.addFields(&quot;addGems&quot;, { gems = 0, }), }, })   ","version":"Next","tagName":"h2"},{"title":"Basic Migrations​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#basic-migrations","content":" The simplest migration is adding new fields:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, migrationSteps = { Lyra.MigrationStep.addFields(&quot;addSettings&quot;, { settings = { music = true, sfx = true, } }), Lyra.MigrationStep.addFields(&quot;addLevel&quot;, { level = 1, }), }, })   Migration Names Are Permanent Migration names (like &quot;addSettings&quot;) are permanent and help Lyra track which migrations have run. Choose descriptive names that indicate what the migration does, as you can't change them later.  ","version":"Next","tagName":"h2"},{"title":"Transform Steps​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#transform-steps","content":" For more complex changes, use transform steps:  migrationSteps = { Lyra.MigrationStep.transform(&quot;inventoryToItems&quot;, function(data) -- Convert simple inventory list to detailed items data.items = {} for _, item in data.inventory do table.insert(data.items, { id = item, acquired = os.time(), }) end data.inventory = nil return data end), }   ","version":"Next","tagName":"h2"},{"title":"Migration Return Values​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#migration-return-values","content":" Each migration step must return data that will eventually match your schema after all migrations run. This means:  Intermediate migrations can return data in any formatThe final state after all migrations must match your schemaLyra validates the final data against your schema after all migrations complete  For example, this is valid even though the intermediate state doesn't match the final schema:  migrationSteps = { -- First migration returns data that doesn't match final schema Lyra.MigrationStep.transform(&quot;step1&quot;, function(data) return { temporaryField = data.oldField, } }), -- Second migration transforms it to match schema Lyra.MigrationStep.transform(&quot;step2&quot;, function(data) return { newField = data.temporaryField, } }), }   ","version":"Next","tagName":"h2"},{"title":"Multiple Steps​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#multiple-steps","content":" You can chain multiple migration steps. They'll run in the order they're defined, from top to bottom:  migrationSteps = { -- Add new currency Lyra.MigrationStep.addFields(&quot;addGems&quot;, { gems = 0, }), -- Restructure inventory Lyra.MigrationStep.transform(&quot;inventoryV2&quot;, function(data) data.inventory = { items = data.inventory, maxSlots = 20, } return data end), }   Migration Order Is Critical Migrations always run in the order they're defined. This order becomes permanent once published - you can't change it later. If a new migration needs data from an older one, add it after the existing migrations.  ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#best-practices","content":" When working with migrations:  Plan carefully - Once published, migrations can't be changedKeep migrations simple - One logical change per stepTest thoroughly - Migrations run once and can't be undone  ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Data Migrations","url":"/lyra/docs/advanced/migrations#see-also","content":" Getting Started for basic Lyra usageDebugging for troubleshooting migrationsCore Concepts for understanding how Lyra works ","version":"Next","tagName":"h2"},{"title":"Debugging","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/debugging","content":"","keywords":"","version":"Next"},{"title":"Understanding Logs​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#understanding-logs","content":" Each log message contains:  A severity levelA descriptive messageOptional context with additional details  Here's a basic setup that prints all logs:  local function handleLogs(message) print(`[Lyra][{string.upper(message.level)}] {message.message}`) if message.context then -- Context contains relevant data like keys, session info, etc. print(&quot;Context:&quot;, message.context) end end local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, logCallback = handleLogs, })   ","version":"Next","tagName":"h2"},{"title":"Log Levels​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#log-levels","content":" Lyra uses different levels to categorize logs:  local function handleLogs(message) -- Handle based on severity if message.level == &quot;fatal&quot; then -- Unrecoverable errors (e.g., corrupted data) warn(&quot;FATAL:&quot;, message.message) elseif message.level == &quot;error&quot; then -- Operation failures (e.g., update failed) warn(&quot;Error:&quot;, message.message) elseif message.level == &quot;warn&quot; then -- Potential issues (e.g., slow operations) warn(&quot;Warning:&quot;, message.message) elseif message.level == &quot;info&quot; then -- Important operations (e.g., session started) print(&quot;Info:&quot;, message.message) elseif message.level == &quot;debug&quot; then -- Detailed operation info print(&quot;Debug:&quot;, message.message) elseif message.level == &quot;trace&quot; then -- Very detailed debugging info print(&quot;Trace:&quot;, message.message) end end   ","version":"Next","tagName":"h2"},{"title":"Development Mode​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#development-mode","content":" You often want more detailed logs in Studio:  local RunService = game:GetService(&quot;RunService&quot;) local function createLogger() if RunService:IsStudio() then -- Show all logs in Studio return function(message) print(`[Lyra][{message.level}] {message.message}`) if message.context then print(&quot;Context:&quot;, message.context) end end else -- Only show errors in production return function(message) if message.level == &quot;error&quot; or message.level == &quot;fatal&quot; then warn(`[Lyra] {message.message}`) end end end end local store = Lyra.createPlayerStore({ logCallback = createLogger(), })   tip The context object often contains useful debugging information like session IDs, keys being operated on, and timing data.  ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Debugging","url":"/lyra/docs/advanced/debugging#see-also","content":" Core Concepts for understanding operationsGetting Started for basic setup ","version":"Next","tagName":"h2"},{"title":"Network Updates","type":0,"sectionRef":"#","url":"/lyra/docs/advanced/networking","content":"","keywords":"","version":"Next"},{"title":"Understanding Change Callbacks​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#understanding-change-callbacks","content":" Change callbacks are functions that run whenever data changes, whether through updates or transactions. They receive three parameters:  The key (player UserId as a string)The new data (frozen to prevent mutations)The previous data (if any, also frozen)  Here's a basic example:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Network = require(ReplicatedStorage.Network) local function syncWithClient(key: string, newData, oldData) local player = Players:GetPlayerByUserId(tonumber(key)) if not player then return end if oldData == nil then -- First time data is loaded Network.PlayerData:FireClient(player, newData) return end -- Send only changed data local changes = {} if newData.coins ~= oldData.coins then changes.coins = newData.coins end if not Tables.deepEquals(newData.inventory, oldData.inventory) then changes.inventory = newData.inventory end -- Send changes to client Network.PlayerData:FireClient(player, changes) end local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, changedCallbacks = { syncWithClient }, })   tip Compare old and new data to send only changed values, reducing network traffic.  ","version":"Next","tagName":"h2"},{"title":"Multiple Callbacks​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#multiple-callbacks","content":" While changedCallbacks are primarily used for networking, you can register multiple callbacks if needed. Each callback receives the same read-only data:  local store = Lyra.createPlayerStore({ changedCallbacks = { -- Keep clients in sync syncWithClient, -- Log changes for debugging function(key, newData, oldData) print(`Player {key} data changed`) end, }, })   ","version":"Next","tagName":"h2"},{"title":"Data Safety​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#data-safety","content":" Change callbacks receive frozen copies of the data. This means the data is read-only and cannot be modified:  local function callback(key, newData, oldData) -- ❌ This will error - data is frozen newData.coins = 100 end   ","version":"Next","tagName":"h2"},{"title":"See Also​","type":1,"pageTitle":"Network Updates","url":"/lyra/docs/advanced/networking#see-also","content":" Core Concepts for understanding data managementGetting Started for basic setup ","version":"Next","tagName":"h2"},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/lyra/docs/core-concepts","content":"","keywords":"","version":"Next"},{"title":"Understanding Sessions​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#understanding-sessions","content":" When a player joins your game, you need a way to work with their data. A session is Lyra's way of managing this connection between your game and a player's saved data.  Sessions utilize 'session locking' to keep data safe. When you load a player's data, Lyra 'locks' it, which gives your server exclusive access to that data. This is crucial - without session locking, multiple servers might try to modify the same player's data simultaneously, leading to race conditions and lost data.  Here's how you work with sessions:  Players.PlayerAdded:Connect(function(player) -- Establish exclusive access to the player's data store:loadAsync(player) end) Players.PlayerRemoving:Connect(function(player) -- Release the lock and save any pending changes store:unloadAsync(player) end)   Loading a session is always your first step. Any attempts to access or modify data before establishing a session will fail, as Lyra needs to ensure exclusive access before allowing operations.  ","version":"Next","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#working-with-data","content":" Once you have a session, you can start working with the player's data. Lyra provides a structured way to make changes through updates.  An update is a function that receives the current data and can modify it mutably. The function must return true to commit the changes, providing an atomic way to perform conditional updates:  store:updateAsync(player, function(data) if data.coins &lt; itemPrice then return false -- Abort the update end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end)   This pattern enables you to encapsulate your game's logic within updates while ensuring data consistency. The update either succeeds completely or fails entirely - there's no possibility of partial changes.  Don't Yield! Lyra enforces that updates are synchronous and non-blocking - if you yield inside the update function, it will error and abort the operation.  ","version":"Next","tagName":"h2"},{"title":"Automatic Data Persistence​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#automatic-data-persistence","content":" Lyra takes care of saving your data automatically. Every 5 minutes, it performs an autosave operation for all active sessions, ensuring your players' progress is regularly persisted to DataStore without any manual intervention required.  To ensure all data is properly saved when the game shuts down, you must call store:closeAsync() inside BindToClose. Lyra doesn't do this for you in case you need to do anything before calling it (usually not):  game:BindToClose(function() store:closeAsync() end)   ","version":"Next","tagName":"h2"},{"title":"Handling Multiple Players​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#handling-multiple-players","content":" Sometimes you need to coordinate changes across multiple players, like in a trading system.  If you update each player individually, there's no guarantee that one player's changes will succeed while the other's fail - imagine a server crashing at exactly the right moment.  This is where transactions come in.  A transaction lets you modify multiple players' data atomically. Either all the changes succeed, or none of them do. This is crucial for maintaining data consistency:  store:txAsync({player1, player2}, function(state) local item = table.remove(state[player1].inventory, 1) if not item then return false -- Abort the transaction end table.insert(state[player2].inventory, item) return true end)   The transaction ensures the atomicity of multi-player operations. You'll never end up in a state where an item has been removed from one player but not added to another, which is essential for maintaining the integrity of your game's economy.  ","version":"Next","tagName":"h2"},{"title":"Data Validation​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#data-validation","content":" Data validation in Lyra works through schemas. When you create a store, you define what valid data looks like:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = { coins = 0, inventory = {}, }, schema = t.strictInterface({ coins = t.number, inventory = t.table, }), })   Lyra enforces this schema on every operation, creating a safe boundary between your game logic and DataStores. If an operation would result in invalid data, Lyra rejects it before it can be saved.  tip We recommend using 't', a Runtime Typechecker for Roblox for defining schemas!  ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Core Concepts","url":"/lyra/docs/core-concepts#next-steps","content":" Now that you understand the core concepts, you might want to:  Learn about migrations for updating your data formatExplore debugging for troubleshootingSee how to handle network updates ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/lyra/docs/getting-started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#installation","content":" Add Lyra to your wally.toml:  Lyra = &quot;paradoxum-games/lyra@0.4.1&quot;   tip If you're new to Wally, check out the Wally installation guide.  ","version":"Next","tagName":"h2"},{"title":"Basic Setup​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#basic-setup","content":" Here's how to set up Lyra with a simple data structure:  local Players = game:GetService(&quot;Players&quot;) local Lyra = require(path.to.Lyra) -- Define your data template local template = { coins = 0, inventory = {}, } -- Create schema to validate data local schema = t.strictInterface({ coins = t.number, inventory = t.table, }) -- Create the store local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, }) -- Load data when players join Players.PlayerAdded:Connect(function(player) store:loadAsync(player) end) -- Save and clean up when they leave Players.PlayerRemoving:Connect(function(player) store:unloadAsync(player) end) -- Ensure data is saved when the game closes game:BindToClose(function() store:closeAsync() end)   ","version":"Next","tagName":"h2"},{"title":"Working with Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#working-with-data","content":" ","version":"Next","tagName":"h2"},{"title":"Reading Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#reading-data","content":" You can read player data, but remember that it might change between reads:  -- ⚠️ Only use this data for reading -- Don't save it for later use local data = store:getAsync(player) print(`{player.Name} has {data.coins} coins`)   ","version":"Next","tagName":"h3"},{"title":"Modifying Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#modifying-data","content":" Always modify data through update functions:  -- Simple update store:updateAsync(player, function(data) data.coins += 100 return true end) -- Conditional update store:updateAsync(player, function(data) if data.coins &lt; itemPrice then return false -- Abort the update end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end)   ","version":"Next","tagName":"h3"},{"title":"Trading Between Players​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#trading-between-players","content":" Use transactions for operations involving multiple players:  store:txAsync({player1, player2}, function(state) -- Transfer coins if state[player1].coins &lt; amount then return false -- Abort if not enough coins end state[player1].coins -= amount state[player2].coins += amount return true end)   ","version":"Next","tagName":"h3"},{"title":"Importing Existing Data​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#importing-existing-data","content":" If you're migrating from another DataStore library, you can import your existing data:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, importLegacyData = function(key) local success, data = pcall(function() return YourCurrentSystem.getData(key) end) if not success then error(&quot;Failed to reach data system&quot;) -- Player will be kicked and can retry end if data ~= nil then return data -- Return existing data to import end return nil -- Return nil for new players to use template end, })   ","version":"Next","tagName":"h2"},{"title":"ProcessReceipt Example​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#processreceipt-example","content":" Here's an example of how you would use Lyra in ProcessReceipt:  local ProductCallbacks = { [12345] = function(player, receiptInfo, data) data.coins += 100 return true end, } local function processReceipt(receiptInfo) local player = Players:GetPlayerByUserId(receiptInfo.PlayerId) if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end local productCallback = ProductCallbacks[receiptInfo.ProductId] if not productCallback then return Enum.ProductPurchaseDecision.NotProcessedYet end local ok, result = pcall(function() store:updateAsync(player, function(data) -- Assuming you have 'purchaseHistory' in your template and schema: if table.find(data.purchaseHistory, receiptInfo.PurchaseId) then return false -- Prevent duplicate purchases end table.insert(data.purchaseHistory, receiptInfo.PurchaseId, 1) for i = 1000, #data.purchaseHistory do data.purchaseHistory[i] = nil -- Remove old purchases end return productCallback(player, receiptInfo, data) end) store:saveAsync(player) end) if not ok then warn(`ProcessReceipt failed: {result}`) return Enum.ProductPurchaseDecision.NotProcessedYet end return Enum.ProductPurchaseDecision.PurchaseGranted end   ","version":"Next","tagName":"h2"},{"title":"Promise-based API​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#promise-based-api","content":" Lyra also offers a Promise-based API:  store:update(player, function(data) data.coins -= itemPrice data.inventory.weapon = &quot;starter_sword&quot; return true end):andThen(function() print(&quot;Purchase successful!&quot;) end):catch(function(err) print(`Purchase failed: {err}`) end)   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"/lyra/docs/getting-started#next-steps","content":" Now that you've got the basics down, check out:  Core Concepts for a deeper understandingData Migrations for updating data structureNetwork Updates for client synchronizationDebugging for troubleshooting ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/lyra/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#features","content":" Transactions - A powerful tool to implement features like trading, while making bugs like item duplication impossibleSession Locking - Prevents common bugs that lead to corruption and data lossValidation - Ensures your data is always in a consistent stateAuto-Sharding - Handles large data by automatically splitting across multiple DataStore keysMigrations - Update your data format without breaking existing savesDrop-in - Import your existing data and switch over seamlessly  ","version":"Next","tagName":"h2"},{"title":"Quick Example​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#quick-example","content":" Here's what using Lyra looks like:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = { coins = 0, inventory = {}, }, schema = t.strictInterface({ coins = t.number, inventory = t.table, }), }) -- Load data when players join Players.PlayerAdded:Connect(function(player) store:loadAsync(player) end) -- Safe updates with validation store:updateAsync(player, function(data) if data.coins &lt; itemPrice then return false -- Abort if can't afford end data.coins -= itemPrice table.insert(data.inventory, itemId) return true end) -- Atomic trades between players store:txAsync({player1, player2}, function(state) -- Either both changes happen or neither does state[player1].coins -= 100 state[player2].coins += 100 return true end)   Avoid Stale Data Always modify data through update functions. Never use data from a previous :get() call: -- 🚫 Don't do this: local oldData = store:getAsync(player) store:updateAsync(player, function(newData) if not oldData.claimedDailyReward then -- This data might be stale! return false end newData.coins += 500 newData.claimedDailyReward = true return true end) -- ✅ Do this instead: store:updateAsync(player, function(data) if not data.claimedDailyReward then -- This data is always current return false end data.coins += 500 data.claimedDailyReward = true return true end)   ","version":"Next","tagName":"h2"},{"title":"Importing Existing Data​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#importing-existing-data","content":" When switching to Lyra, you can bring your existing data:  local store = Lyra.createPlayerStore({ name = &quot;PlayerData&quot;, template = template, schema = schema, importLegacyData = function(key) local success, data = pcall(function() return YourCurrentSystem.getData(key) end) if not success then -- If there's an error, Lyra will kick the player and prompt them -- to rejoin to try again. error(&quot;Failed to reach data system&quot;) end if data ~= nil then return data -- Return existing data to import end return nil -- Return nil for new players to use template end, })   ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#installation","content":" Add to your wally.toml:  Lyra = &quot;paradoxum-games/lyra@0.4.1&quot;   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/lyra/docs/intro#next-steps","content":" Check out Getting Started for a complete setup guideRead Core Concepts to understand how Lyra worksSee the Advanced Features section for migration guides and debugging tips ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}