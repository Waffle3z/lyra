"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8613],{56992:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"advanced/state-management","title":"State Management and Lyra","description":"Lyra as the Source of Truth","source":"@site/docs/advanced/state-management.md","sourceDirName":"advanced","slug":"/advanced/state-management","permalink":"/lyra/docs/advanced/state-management","draft":false,"unlisted":false,"editUrl":"https://github.com/paradoxum-games/lyra/edit/main/docs/advanced/state-management.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Debugging","permalink":"/lyra/docs/advanced/debugging"}}');var s=t(74848),r=t(28453);const o={sidebar_position:3},i="State Management and Lyra",d={},l=[{value:"Lyra as the Source of Truth",id:"lyra-as-the-source-of-truth",level:2},{value:"Common Integration Patterns",id:"common-integration-patterns",level:3},{value:"Pattern 1: External State as Source of Truth (Not Recommended)",id:"pattern-1-external-state-as-source-of-truth-not-recommended",level:4},{value:"Pattern 2: Lyra as Source of Truth (Recommended)",id:"pattern-2-lyra-as-source-of-truth-recommended",level:4},{value:"Why Lyra Should Be the Source of Truth",id:"why-lyra-should-be-the-source-of-truth",level:3},{value:"The Technical Reason",id:"the-technical-reason",level:3},{value:"Practical Integration Strategies",id:"practical-integration-strategies",level:2},{value:"For Game Systems and Services",id:"for-game-systems-and-services",level:3},{value:"Deriving State from Lyra",id:"deriving-state-from-lyra",level:3},{value:"Common Questions",id:"common-questions",level:2},{value:"&quot;How do I handle complex state that isn&#39;t just player data?&quot;",id:"how-do-i-handle-complex-state-that-isnt-just-player-data",level:3},{value:"&quot;What about systems that need to react to data changes?&quot;",id:"what-about-systems-that-need-to-react-to-data-changes",level:3},{value:"Recap",id:"recap",level:2}];function c(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"state-management-and-lyra",children:"State Management and Lyra"})}),"\n",(0,s.jsx)(a.h2,{id:"lyra-as-the-source-of-truth",children:"Lyra as the Source of Truth"}),"\n",(0,s.jsxs)(a.p,{children:["When building games with Lyra, it's important to understand that ",(0,s.jsx)(a.strong,{children:"Lyra is designed to be the source of truth for your data"}),". This design choice enables Lyra to provide strong guarantees about data consistency and integrity."]}),"\n",(0,s.jsx)(a.h3,{id:"common-integration-patterns",children:"Common Integration Patterns"}),"\n",(0,s.jsx)(a.p,{children:"Some developers use state management libraries like Reflex, Charm, or custom solutions alongside Lyra. When integrating these tools, there are two common approaches:"}),"\n",(0,s.jsx)(a.h4,{id:"pattern-1-external-state-as-source-of-truth-not-recommended",children:"Pattern 1: External State as Source of Truth (Not Recommended)"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-lua",children:"-- External state is the primary source of truth\nfunction giveCoins(player, amount)\n    -- Update external state first\n    gameState.players[player.UserId].coins += amount\n\n\t-- Then flush to Lyra as a secondary step\n\tstore:updateAsync(player.UserId, function(data)\n\t\tdata.coins = gameState.players[player.UserId].coins\n\t\treturn true\n\tend)\nend\n"})}),"\n",(0,s.jsx)(a.h4,{id:"pattern-2-lyra-as-source-of-truth-recommended",children:"Pattern 2: Lyra as Source of Truth (Recommended)"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-lua",children:"-- Lyra is the primary source of truth\nfunction giveCoins(player, amount)\n    -- Update Lyra first\n    store:updateAsync(player.UserId, function(data)\n        data.coins += amount\n        return true\n    end)\n    \n    -- Other systems can derive from Lyra through changedCallbacks\nend\n"})}),"\n",(0,s.jsx)(a.h3,{id:"why-lyra-should-be-the-source-of-truth",children:"Why Lyra Should Be the Source of Truth"}),"\n",(0,s.jsx)(a.p,{children:"When Lyra isn't the primary source of truth, several key features become compromised:"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Atomicity"}),": Lyra's updates are atomic - they either succeed completely or fail entirely. This guarantee is lost when changes originate elsewhere."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Transactions"}),": Lyra's transactions allow updating multiple players' data atomically - a feature that requires Lyra to control the data flow."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Data Consistency"}),": When external state and Lyra diverge (e.g., if a Lyra update fails), reconciling the differences becomes complex."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Schema Validation"}),": Lyra validates data against your schema during updates, catching issues early. When changes happen outside Lyra, these validations are bypassed, leading to potential data corruption."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"the-technical-reason",children:"The Technical Reason"}),"\n",(0,s.jsx)(a.p,{children:"Behind the scenes, Lyra maintains data integrity through a carefully orchestrated system:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Updates and transactions are queued and processed in sequence"}),"\n",(0,s.jsx)(a.li,{children:"Transactions require waiting for some DataStore calls to guarantee atomicity"}),"\n",(0,s.jsx)(a.li,{children:"During a transaction, updates to affected keys are paused until the transaction completes"}),"\n",(0,s.jsx)(a.li,{children:"This is necessary because changes from transactions are only considered valid if all DataStore operations succeed"}),"\n",(0,s.jsx)(a.li,{children:"If any operation fails, Lyra discards all pending changes to maintain consistency"}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"If external systems modify data at the same time Lyra is processing a transaction, this careful balance breaks down. The only way to handle such conflicts would require complex rollback mechanisms that impose significant constraints on your code structure."}),"\n",(0,s.jsx)(a.p,{children:"By making Lyra the source of truth, you get robust data integrity without these complications."}),"\n",(0,s.jsx)(a.h2,{id:"practical-integration-strategies",children:"Practical Integration Strategies"}),"\n",(0,s.jsx)(a.p,{children:"If you're using a state management library alongside Lyra, consider these approaches:"}),"\n",(0,s.jsx)(a.h3,{id:"for-game-systems-and-services",children:"For Game Systems and Services"}),"\n",(0,s.jsx)(a.p,{children:"Use your state management library for ephemeral game state, while letting Lyra handle persistent player data:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-lua",children:"-- Lyra handles persistent data\nstore:updateAsync(player.UserId, function(data)\n    data.questProgress.questId = 5\n    data.questProgress.stepsCompleted += 1\n    return true\nend)\n\n-- Game systems can track active state separately\ngameState.activeQuests[player.UserId] = {\n    questId = 5,\n    timeRemaining = 600,\n    location = workspace.QuestLocations.Cave\n}\n"})}),"\n",(0,s.jsx)(a.h3,{id:"deriving-state-from-lyra",children:"Deriving State from Lyra"}),"\n",(0,s.jsx)(a.p,{children:"Let Lyra drive updates to the rest of your code through callbacks:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-lua",children:"-- When Lyra data changes, update external state\nchangedCallbacks = {\n    function(key, newData, oldData)\n        local playerId = tonumber(key)\n\t\tgameState.players[playerId][key] = newData[key]\n    end\n}\n"})}),"\n",(0,s.jsx)(a.h2,{id:"common-questions",children:"Common Questions"}),"\n",(0,s.jsx)(a.h3,{id:"how-do-i-handle-complex-state-that-isnt-just-player-data",children:'"How do I handle complex state that isn\'t just player data?"'}),"\n",(0,s.jsx)(a.p,{children:"Lyra is primarily designed for persistent player data. For state that doesn't need persistence, it's fine to use other state management approaches:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-lua",children:"-- State that doesn't need persistence\nlocal gameState = {\n    currentRound = 1,\n    roundStartTime = os.time(),\n    activePlayers = {},\n}\n\n-- Player data that needs persistence uses Lyra\nfunction playerCompletedRound(player)\n\tlocal score = gameState.roundScores[player.UserId] or 0\n    store:updateAsync(player.UserId, function(data)\n        data.roundsCompleted += 1\n        data.totalScore += score\n        return true\n    end)\nend\n"})}),"\n",(0,s.jsx)(a.h3,{id:"what-about-systems-that-need-to-react-to-data-changes",children:'"What about systems that need to react to data changes?"'}),"\n",(0,s.jsx)(a.p,{children:"You can use Lyra's changedCallbacks to notify other systems when data changes:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-lua",children:"-- Set up a badge award system that reacts to data changes\nchangedCallbacks = {\n    function(key, newData, oldData)\n\t\tif oldData == nil then return end\n        local playerId = tonumber(key)\n        \n        -- Check if player reached a milestone\n        if oldData.coins < 1000 and newData.coins >= 1000 {\n            BadgeService.awardBadge(playerId, BADGES.COIN_COLLECTOR)\n        }\n        \n        -- Check if player completed all quests\n        if #oldData.completedQuests < 10 and #newData.completedQuests >= 10 {\n            BadgeService.awardBadge(playerId, BADGES.QUEST_MASTER)\n        }\n    end\n}\n"})}),"\n",(0,s.jsx)(a.h2,{id:"recap",children:"Recap"}),"\n",(0,s.jsx)(a.p,{children:"While it might be tempting to use another state management system as your primary source of truth, doing so limits Lyra's ability to provide its core benefits. By keeping Lyra as the source of truth for persistent data, you'll build more robust games with fewer data-related issues."})]})}function h(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>o,x:()=>i});var n=t(96540);const s={},r=n.createContext(s);function o(e){const a=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:a},e.children)}}}]);