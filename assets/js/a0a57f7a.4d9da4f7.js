"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[561],{4161:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"advanced/migrations","title":"Data Migrations","description":"As your game evolves, you\'ll need to update your data format - adding new fields, renaming existing ones, or restructuring data entirely. Lyra\'s migration system helps you transform existing player data safely and automatically.","source":"@site/docs/advanced/migrations.md","sourceDirName":"advanced","slug":"/advanced/migrations","permalink":"/docs/advanced/migrations","draft":false,"unlisted":false,"editUrl":"https://github.com/paradoxum-games/lyra/edit/main/docs/advanced/migrations.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","previous":{"title":"Core Concepts","permalink":"/docs/core-concepts"},"next":{"title":"Network Updates","permalink":"/docs/advanced/networking"}}');var t=i(4848),s=i(8453);const r={sidebar_position:1},o="Data Migrations",d={},l=[{value:"How Migrations Work",id:"how-migrations-work",level:2},{value:"Basic Migrations",id:"basic-migrations",level:2},{value:"Transform Steps",id:"transform-steps",level:2},{value:"Multiple Steps",id:"multiple-steps",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"data-migrations",children:"Data Migrations"})}),"\n",(0,t.jsx)(n.p,{children:"As your game evolves, you'll need to update your data format - adding new fields, renaming existing ones, or restructuring data entirely. Lyra's migration system helps you transform existing player data safely and automatically."}),"\n",(0,t.jsxs)(n.admonition,{title:"Never Change Published Migrations",type:"danger",children:[(0,t.jsx)(n.p,{children:"Once your game is live, never:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Change the content of existing migrations"}),"\n",(0,t.jsx)(n.li,{children:"Reorder existing migrations"}),"\n",(0,t.jsx)(n.li,{children:"Remove existing migrations"}),"\n"]}),(0,t.jsx)(n.p,{children:"Lyra tracks which migrations have run for each player. Changing existing migrations means some players will run different versions of the same migration, corrupting their data. Always add new migrations instead of modifying existing ones."})]}),"\n",(0,t.jsx)(n.h2,{id:"how-migrations-work",children:"How Migrations Work"}),"\n",(0,t.jsx)(n.p,{children:"When a player's data is loaded, Lyra:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Checks which migrations have already run for this player"}),"\n",(0,t.jsx)(n.li,{children:"Runs any new migrations in order"}),"\n",(0,t.jsx)(n.li,{children:"Records which migrations were applied"}),"\n",(0,t.jsx)(n.li,{children:"Validates the final data against your schema"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This means each migration runs exactly once per player, even if they join multiple times or on different servers."}),"\n",(0,t.jsx)(n.h2,{id:"basic-migrations",children:"Basic Migrations"}),"\n",(0,t.jsx)(n.p,{children:"The simplest migration is adding new fields:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local store = Lyra.createPlayerStore({\n    name = "PlayerData",\n    template = template,\n    schema = schema,\n    migrationSteps = Lyra.Migration.new()\n        :fields("add_player_settings", {\n            settings = {\n                music = true,\n                sfx = true,\n            }\n        })\n        :finalize(),\n})\n'})}),"\n",(0,t.jsx)(n.admonition,{title:"Migration Names Are Permanent",type:"warning",children:(0,t.jsx)(n.p,{children:'Migration names (like "add_player_settings") are permanent and help Lyra track which migrations have run. Choose descriptive names that indicate what the migration does, as you can\'t change them later.'})}),"\n",(0,t.jsx)(n.h2,{id:"transform-steps",children:"Transform Steps"}),"\n",(0,t.jsxs)(n.p,{children:["For more complex changes, use ",(0,t.jsx)(n.code,{children:"transform"})," steps:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'migrationSteps = Lyra.Migration.new()\n    :transform("inventory_to_items", function(data)\n        -- Convert simple inventory list to detailed items\n        data.items = {}\n        for item in data.inventory do\n            table.insert(data.items, {\n                id = item,\n                acquired = os.time(),\n            })\n        end\n        data.inventory = nil\n        return data\n    end)\n    :finalize()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"multiple-steps",children:"Multiple Steps"}),"\n",(0,t.jsx)(n.p,{children:"You can chain multiple migration steps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'migrationSteps = Lyra.Migration.new()\n    -- Add new currency\n    :fields("add_gems", {\n        gems = 0,\n    })\n    -- Restructure inventory\n    :transform("inventory_v2", function(data)\n        data.inventory = {\n            items = data.inventory,\n            maxSlots = 20,\n        }\n        return data\n    end)\n    :finalize()\n'})}),"\n",(0,t.jsx)(n.admonition,{title:"Migration Order Is Critical",type:"caution",children:(0,t.jsx)(n.p,{children:"Migrations always run in the order they're defined. This order becomes permanent once published - you can't change it later. If a new migration needs data from an older one, add it after the existing migrations."})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"When working with migrations:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plan carefully"})," - Once published, migrations can't be changed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keep migrations simple"})," - One logical change per step"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle edge cases"})," - Check if fields exist before accessing them"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test thoroughly"})," - Migrations run once and can't be undone"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/getting-started",children:"Getting Started"})," for basic Lyra usage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/advanced/debugging",children:"Debugging"})," for troubleshooting migrations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/core-concepts",children:"Core Concepts"})," for understanding how Lyra works"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var a=i(6540);const t={},s=a.createContext(t);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);