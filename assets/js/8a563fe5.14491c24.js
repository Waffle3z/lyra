"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9090],{83245:e=>{e.exports=JSON.parse('{"functions":[{"name":"createStore","desc":"Factory function to create a new Store instance.\\n\\nInitializes the store context, sets up DataStore and MemoryStore connections\\n(real or mock), validates the template schema, and returns the configured Store object.","params":[{"name":"config","desc":"Configuration options for the store.","lua_type":"StoreConfig<T>"}],"returns":[{"desc":"A new, initialized Store instance.","lua_type":"Store<T>"}],"function_type":"static","source":{"line":206,"path":"src/Store.luau"}},{"name":"load","desc":"Acquires a distributed lock, loads data for the given key into memory, \\nand establishes a `Session` object to manage the key\'s state.\\n\\nThis must be called before performing operations like `get`, `update`, or `save`\\non the key. It handles concurrent load attempts and waits for any ongoing unload\\noperations to complete first.\\n\\nPropagates errors from `Session.load` (e.g., lock acquisition failure, DataStore errors).","params":[{"name":"key","desc":"The unique identifier for the data to load (e.g., \\"player_123\\").","lua_type":"string"},{"name":"userIds","desc":"Optional list of UserIDs for DataStore key tagging.","lua_type":"{number}?"}],"returns":[{"desc":"Resolves when the data is successfully loaded and the session is ready, or rejects on error.","lua_type":"Promise"}],"function_type":"method","errors":[{"lua_type":"\\"Load already in progress\\"","desc":"If `load` is called again for the same key while a previous load is still running."},{"lua_type":"\\"Store is closed\\"","desc":"If the store instance has been closed via `close()`."}],"source":{"line":342,"path":"src/Store.luau"}},{"name":"loadAsync","desc":"Synchronous wrapper for [Store:load]. Waits for the Promise to settle.\\nThrows an error if the load fails or is cancelled.","params":[{"name":"key","desc":"The unique identifier for the data to load.","lua_type":"string"},{"name":"userIds","desc":"Optional list of UserIDs for DataStore key tagging.","lua_type":"{number}?"}],"returns":[],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the load process."}],"yields":true,"source":{"line":451,"path":"src/Store.luau"}},{"name":"unload","desc":"Unloads data for the given key from memory, saves any pending changes,\\nreleases the distributed lock, and ends the session.\\n\\nPropagates errors from `Session:unload` (e.g., save failures).","params":[{"name":"key","desc":"The unique identifier for the data to unload.","lua_type":"string"}],"returns":[{"desc":"Resolves when the data is successfully unloaded, or rejects on error.","lua_type":"Promise"}],"function_type":"method","errors":[{"lua_type":"\\"Store is closed\\"","desc":"If the store instance has been closed."}],"source":{"line":466,"path":"src/Store.luau"}},{"name":"unloadAsync","desc":"Synchronous wrapper for [Store:unload]. Waits for the Promise to settle.\\nThrows an error if the unload fails.","params":[{"name":"key","desc":"The unique identifier for the data to unload.","lua_type":"string"}],"returns":[],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the unload process."}],"yields":true,"source":{"line":520,"path":"src/Store.luau"}},{"name":"_withSession","desc":"Internal helper function to safely access the session for a given key.\\nHandles waiting for load/unload operations and checks store/session state.","params":[{"name":"key","desc":"The key whose session is needed.","lua_type":"string"},{"name":"callback","desc":"The function to execute with the session object.","lua_type":"(session: Session.Session<any>) -> any"}],"returns":[{"desc":"Resolves with the return value of the callback, or rejects if the session cannot be accessed (e.g., not loaded, store closed, load cancelled).","lua_type":"Promise"}],"function_type":"method","private":true,"source":{"line":534,"path":"src/Store.luau"}},{"name":"_getKeyInfo","desc":"Internal helper to get the DataStoreKeyInfo for a loaded key\'s session.","params":[{"name":"key","desc":"The key whose info is needed.","lua_type":"string"}],"returns":[{"desc":"Resolves with the key info object, or nil if the session doesn\'t have key info (shouldn\'t normally happen for loaded sessions). Rejects if the session cannot be accessed.","lua_type":"Promise<DataStoreKeyInfo?>"}],"function_type":"method","private":true,"source":{"line":587,"path":"src/Store.luau"}},{"name":"get","desc":"Gets the current, in-memory data state for the given key.\\nRequires the key to be loaded first via `load()`.\\nIf the key is still loading, this will wait for it to finish.","params":[{"name":"key","desc":"The key whose data to retrieve.","lua_type":"string"}],"returns":[{"desc":"Resolves with the current data object (potentially a deep copy).","lua_type":"Promise<T>"}],"function_type":"method","errors":[{"lua_type":"\\"Key not loaded\\"","desc":"If `load()` has not been successfully called for this key."},{"lua_type":"\\"Store is closed\\"","desc":"If the store has been closed."}],"source":{"line":605,"path":"src/Store.luau"}},{"name":"getAsync","desc":"Synchronous wrapper for [Store:get]. Waits for the Promise to settle.\\nThrows an error if getting the data fails.","params":[{"name":"key","desc":"The key whose data to retrieve.","lua_type":"string"}],"returns":[{"desc":"The current data object.","lua_type":"T"}],"function_type":"method","errors":[{"lua_type":"\\"Key not loaded\\"","desc":"If `load()` has not been successfully called for this key."},{"lua_type":"\\"Store is closed\\"","desc":"If the store has been closed."}],"yields":true,"source":{"line":624,"path":"src/Store.luau"}},{"name":"update","desc":"Applies changes to the data for a given key using a transform function.\\n\\nThe `transformFunction` receives the current data (potentially a deep copy, see\\n`disableReferenceProtection`) and can modify it directly. It **must** return `true`\\nto indicate that changes were made and should be saved, or `false` to abort the\\nupdate without saving.\\n\\nChanges are applied optimistically to the in-memory state first and then queued\\nfor saving to the DataStore.","params":[{"name":"key","desc":"The key whose data to update.","lua_type":"string"},{"name":"transformFunction","desc":"A function that receives the current data and returns `true` to commit changes or `false` to abort.","lua_type":"(data: T) -> boolean"}],"returns":[{"desc":"Resolves with `true` if the transform function returned `true` and the update was successfully queued, or `false` if the transform function returned `false`. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation.","lua_type":"Promise<boolean>"}],"function_type":"method","errors":[{"lua_type":"\\"Key not loaded\\"","desc":"If `load()` has not been successfully called for this key."},{"lua_type":"\\"Store is closed\\"","desc":"If the store instance has been closed."},{"lua_type":"\\"Schema validation failed\\"","desc":"If the data returned by `transformFunction` does not pass the store\'s schema check."}],"source":{"line":647,"path":"src/Store.luau"}},{"name":"updateAsync","desc":"Synchronous wrapper for [Store:update]. Waits for the Promise to settle.\\nThrows an error if the update fails.","params":[{"name":"key","desc":"The key whose data to update.","lua_type":"string"},{"name":"transformFunction","desc":"The transformation function.","lua_type":"(data: T) -> boolean"}],"returns":[{"desc":"Returns the boolean value returned by the `transformFunction`.","lua_type":"boolean"}],"function_type":"method","errors":[{"lua_type":"\\"Key not loaded\\"","desc":"If `load()` has not been successfully called for this key."},{"lua_type":"\\"Store is closed\\"","desc":"If the store instance has been closed."},{"lua_type":"\\"Schema validation failed\\"","desc":"If the data returned by `transformFunction` does not pass the store\'s schema check."}],"yields":true,"source":{"line":670,"path":"src/Store.luau"}},{"name":"tx","desc":"Performs an atomic transaction across multiple keys.\\n\\nEnsures that changes across all specified keys are applied together or not at all.\\nAll involved keys must be loaded via `load()` before calling `tx()`.\\n\\nThe `transformFunction` receives a table where keys are the data keys and values\\nare the current data states. It can modify this state table. It **must** return\\n`true` to commit the transaction or `false` to abort.\\n\\n**Implementation Details:**\\n- Uses `PromiseQueue.multiQueueAdd` to ensure the transform function only runs\\n  when all involved session queues are ready.\\n- Uses a temporary `txLockPromise` on sessions to block concurrent `update` calls\\n  while the transaction logic is executing.\\n- Performs a two-phase commit using a transaction marker in the `txStore`:\\n\\t1. Write `false` to `txStore` under a unique `txId`.\\n\\t2. Update all primary `recordStore` entries with the new data and `txId`.\\n\\t3. If successful, remove the `txId` entry from `txStore`.\\n- If any step fails, attempts to revert changes by rewriting records without the `txId`\\n  and removing the `txId` marker.\\n- Uses `JsonPatch` to calculate differences for efficient storage in `TxInfo`.\\n\\nPropagates DataStore errors encountered during the commit or revert phases.","params":[{"name":"keys","desc":"An array of keys involved in the transaction.","lua_type":"{string}"},{"name":"transformFunction","desc":"A function that receives the current state of all keys and returns `true` to commit or `false` to abort.","lua_type":"(state: { [string]: T }) -> boolean"}],"returns":[{"desc":"Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.","lua_type":"Promise"}],"function_type":"method","errors":[{"lua_type":"\\"Key not loaded\\"","desc":"If any key in the `keys` array has not been loaded."},{"lua_type":"\\"Key is already locked by another transaction\\"","desc":"If any key is already involved in an ongoing `tx`."},{"lua_type":"\\"Key is closed\\"","desc":"If any involved session has been closed (e.g., due to lock loss)."},{"lua_type":"\\"Store is closed\\"","desc":"If the store instance has been closed."},{"lua_type":"\\"Schema validation failed\\"","desc":"If the data for any key after transformation fails the schema check."},{"lua_type":"\\"Keys changed in transaction\\"","desc":"If the `transformFunction` attempts to add or remove keys from the state table it receives."}],"source":{"line":710,"path":"src/Store.luau"}},{"name":"txAsync","desc":"Synchronous wrapper for [Store:tx]. Waits for the Promise to settle.\\nThrows an error if the transaction fails or is aborted.","params":[{"name":"keys","desc":"An array of keys involved in the transaction.","lua_type":"{string}"},{"name":"transformFunction","desc":"The transformation function.","lua_type":"(state: { [string]: T }) -> boolean"}],"returns":[],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the transaction."}],"yields":true,"source":{"line":983,"path":"src/Store.luau"}},{"name":"save","desc":"Forces an immediate save of the given key\'s current in-memory data state\\nto the DataStore.\\n\\n:::note\\nData is automatically saved periodically by the Session\'s autosave mechanism.\\nManual saves are typically only needed in specific scenarios like processing\\ndeveloper product purchases (`MarketplaceService.ProcessReceipt`) where immediate\\npersistence is crucial before granting benefits.\\n:::\\n\\nPropagates errors from `Session:save` (e.g., DataStore write errors).","params":[{"name":"key","desc":"The key whose data to save.","lua_type":"string"}],"returns":[{"desc":"Resolves when the save operation completes successfully, rejects on error.","lua_type":"Promise"}],"function_type":"method","errors":[{"lua_type":"\\"Key not loaded\\"","desc":"If `load()` has not been successfully called for this key."},{"lua_type":"\\"Store is closed\\"","desc":"If the store instance has been closed."}],"source":{"line":1006,"path":"src/Store.luau"}},{"name":"saveAsync","desc":"Synchronous wrapper for [Store:save]. Waits for the Promise to settle.\\nThrows an error if the save fails.","params":[{"name":"key","desc":"The key whose data to save.","lua_type":"string"}],"returns":[],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the save operation."}],"yields":true,"source":{"line":1023,"path":"src/Store.luau"}},{"name":"close","desc":"Closes the store, gracefully unloading all active sessions.\\n\\nAttempts to save any pending changes for all loaded keys before releasing locks\\nand removing sessions from memory. The store instance becomes unusable as soon as this is called.","params":[],"returns":[{"desc":"Resolves when all sessions have attempted to unload, or rejects if any session encountered an error during its unload process (errors are aggregated).","lua_type":"Promise"}],"function_type":"method","source":{"line":1036,"path":"src/Store.luau"}},{"name":"closeAsync","desc":"Synchronous wrapper for [Store:close]. Waits for the Promise to settle.\\nThrows an error if closing fails (i.e., if any session failed to unload).","params":[],"returns":[],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws an error (potentially a table of errors) if closing fails."}],"yields":true,"source":{"line":1089,"path":"src/Store.luau"}},{"name":"peek","desc":"Reads the current data for the given key directly from the DataStore,\\nbypassing the session cache and locking mechanism.\\n\\nThis provides a snapshot of the last saved state but does not load the key\\ninto an active session. Useful for inspecting data without acquiring a lock.\\nHandles potential sharding and transaction status automatically.\\n\\nPropagates DataStore errors from underlying reads.","params":[{"name":"key","desc":"The key whose data to peek at.","lua_type":"string"}],"returns":[{"desc":"Resolves with the data object, or `nil` if the key doesn\'t exist. Rejects on DataStore errors.","lua_type":"Promise<T?>"}],"function_type":"method","source":{"line":1107,"path":"src/Store.luau"}},{"name":"peekAsync","desc":"Synchronous wrapper for [Store:peek]. Waits for the Promise to settle.\\nReturns the data for the key if it exists. Throws on any errors from underlying DataStore operations.","params":[{"name":"key","desc":"The key whose data to peek at.","lua_type":"string"}],"returns":[{"desc":"The data object, or `nil` if the key doesn\'t exist.","lua_type":"T?"}],"function_type":"method","errors":[{"lua_type":"any","desc":"May throw errors from underlying DataStore operations."}],"yields":true,"source":{"line":1155,"path":"src/Store.luau"}},{"name":"probeLockActive","desc":"Checks if a distributed lock is currently active for the given key in MemoryStore.\\n\\nPropagates errors from `Locks.probeLockActive`.","params":[{"name":"key","desc":"The key to check the lock status for.","lua_type":"string"}],"returns":[{"desc":"Resolves with `true` if a lock is active, `false` otherwise. Rejects on MemoryStore errors.","lua_type":"Promise<boolean>"}],"function_type":"method","source":{"line":1168,"path":"src/Store.luau"}},{"name":"probeLockActiveAsync","desc":"Synchronous wrapper for [Store:probeLockActive]. Waits for the Promise to settle.\\nThrows an error if the check fails.","params":[{"name":"key","desc":"The key to check the lock status for.","lua_type":"string"}],"returns":[{"desc":"`true` if a lock is active, `false` otherwise.","lua_type":"boolean"}],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the probe operation."}],"yields":true,"source":{"line":1186,"path":"src/Store.luau"}},{"name":"listVersions","desc":"Lists historical versions of the data for a given key using DataStore versioning.\\n\\nPropagates errors from `DataStore:ListVersionsAsync`.","params":[{"name":"params","desc":"Parameters specifying the key, sorting, date range, and page size.","lua_type":"ListVersionParams"}],"returns":[{"desc":"Resolves with an iterator object (`DataStoreVersionPages`) that can be used to fetch pages of version history. Rejects on DataStore errors.","lua_type":"Promise<DataStoreVersionPages>"}],"function_type":"method","source":{"line":1199,"path":"src/Store.luau"}},{"name":"listVersionsAsync","desc":"Synchronous wrapper for [Store:listVersions]. Waits for the Promise to settle.\\nThrows an error if listing versions fails.","params":[{"name":"params","desc":"Parameters for listing versions.","lua_type":"ListVersionParams"}],"returns":[{"desc":"An iterator for version history.","lua_type":"DataStoreVersionPages"}],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the list operation."}],"yields":true,"source":{"line":1222,"path":"src/Store.luau"}},{"name":"readVersion","desc":"Reads the data content of a specific historical version for a given key.\\n\\nPropagates DataStore errors from underlying reads.","params":[{"name":"key","desc":"The key whose version to read.","lua_type":"string"},{"name":"version","desc":"The specific version ID (obtained from `listVersions`).","lua_type":"string"}],"returns":[{"desc":"Resolves with the data object (`T`) and the `DataStoreKeyInfo` for that version. Rejects if the version doesn\'t exist or on DataStore/read errors.","lua_type":"Promise<(T, DataStoreKeyInfo)>"}],"function_type":"method","errors":[{"lua_type":"\\"Record not found\\"","desc":"If the specified version doesn\'t exist."}],"source":{"line":1237,"path":"src/Store.luau"}},{"name":"readVersionAsync","desc":"Synchronous wrapper for [Store:readVersion]. Waits for the Promise to settle.\\nThrows an error if reading the version fails.","params":[{"name":"key","desc":"The key whose version to read.","lua_type":"string"},{"name":"version","desc":"The specific version ID.","lua_type":"string"}],"returns":[{"desc":"The data object for the specified version.","lua_type":"T"},{"desc":"The key info for the specified version.","lua_type":"DataStoreKeyInfo"}],"function_type":"method","errors":[{"lua_type":"any","desc":"Throws any error encountered during the read operation."}],"yields":true,"source":{"line":1281,"path":"src/Store.luau"}}],"properties":[],"types":[{"name":"StoreConfig","desc":"Configuration options for creating a new Store instance using `createStore`.","fields":[{"name":"name","lua_type":"string","desc":"A unique name for this store (e.g., \\"PlayerDataProd\\"). Used for logging and deriving DataStore/MemoryStore keys."},{"name":"template","lua_type":"T","desc":"A deep copyable Luau table/value representing the default state for a new key."},{"name":"schema","lua_type":"(value: any) -> (boolean, string?)","desc":"A validation function (e.g., created with `t`) that checks if data conforms to the expected structure. Returns `true` if valid, or `false` and an error message if invalid."},{"name":"migrationSteps","lua_type":"{Types.MigrationStep}?","desc":"An optional ordered list of migration steps to apply to data loaded from the DataStore if its schema is older than the current version. See `Migrations.luau`."},{"name":"importLegacyData","lua_type":"((key: string) -> any?)?","desc":"An optional function to load data from a different, legacy storage system when a key is accessed for the first time and doesn\'t exist in this store."},{"name":"dataStoreService","lua_type":"DataStoreService?","desc":"An optional override for the Roblox DataStoreService. Useful for testing or custom storage implementations. Defaults to `game:GetService(\\"DataStoreService\\")`."},{"name":"memoryStoreService","lua_type":"MemoryStoreService?","desc":"An optional override for the Roblox MemoryStoreService. Useful for testing. Defaults to `game:GetService(\\"MemoryStoreService\\")`."},{"name":"useMock","lua_type":"boolean?","desc":"If true (and running in Studio), uses mock in-memory implementations of DataStoreService and MemoryStoreService instead of the actual Roblox services. Useful for testing in a controlled environment. Defaults to `false`."},{"name":"changedCallbacks","lua_type":"{ (key: string, newData: T, oldData: T?) -> () }?","desc":"An optional list of functions called *after* data for a key has been successfully updated. Provides the key, the new data state, and the previous data state (if available)."},{"name":"logCallback","lua_type":"((logMessage: Log.LogMessage) -> ())?","desc":"A function to receive log messages generated by this Store instance and its components. If omitted, logs are discarded. See [Log]."},{"name":"onLockLost","lua_type":"((key: string) -> ())?","desc":"An optional callback function triggered if the distributed lock for a key\'s session is lost unexpectedly (e.g., due to expiration or external interference). This usually indicates the session is no longer safe to use."},{"name":"disableReferenceProtection","lua_type":"boolean?","desc":"If true, disables deep copying of data returned by `get()`. This can improve performance but requires careful handling to avoid accidentally mutating internal Store state. Defaults to `false`."}],"source":{"line":100,"path":"src/Store.luau"}}],"name":"Store","desc":"Coordinates Sessions and provides a safe, high-level API for interacting with\\npersistent data stored in Roblox DataStores and MemoryStores.\\n\\n**Core Responsibilities:**\\n- Manages the lifecycle of `Session` objects for individual data keys (e.g., player IDs).\\n- Provides methods for loading, reading (`get`), updating (`update`), and saving data.\\n- Implements atomic multi-key transactions (`tx`).\\n- Handles data validation, migrations, and optional legacy data import.\\n- Abstracts away underlying complexities like data sharding (`Files`), distributed\\n  locking (`Locks`), and transaction coordination (`Transactions`).\\n- Integrates with a configurable logging system (`Log`).\\n\\n**Usage Example:**\\n```lua\\nlocal store = Store.createStore({\\n\\tname = \\"PlayerData\\",\\n\\ttemplate = {\\n\\t\\tcoins = 0,\\n\\t\\titems = {},\\n\\t},\\n\\tschema = function(data)\\n\\t\\treturn typeof(data.coins) == \\"number\\" and typeof(data.items) == \\"table\\",\\n\\t\\t\\"Invalid data format\\"\\n\\tend,\\n\\t-- ... other config options\\n})\\n\\n-- Load data for a player\\nstore:load(\\"player_1\\"):andThen(function()\\n\\t-- Get current data\\n\\treturn store:get(\\"player_1\\")\\nend):andThen(function(data)\\n\\tprint(data.coins) -- 0\\n\\n\\t-- Update data\\n\\treturn store:update(\\"player_1\\", function(data)\\n\\t\\tdata.coins += 100\\n\\t\\treturn true -- Must return true to commit changes\\n\\tend)\\nend)\\n```","private":true,"source":{"line":47,"path":"src/Store.luau"}}')}}]);